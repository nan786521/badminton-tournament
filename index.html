<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>羽球賽務系統</title>
    <meta name="theme-color" content="#1a73e8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" href="manifest.json">
    <script>
    // Lazy CDN loader — load libraries on demand instead of upfront
    const CDN_LIBS = {
        xlsx: 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js',
        html2canvas: 'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js',
        qrcode: 'https://cdnjs.cloudflare.com/ajax/libs/qrcode-generator/1.4.4/qrcode.min.js'
    };
    const _libLoading = {};
    function loadLib(name) {
        if (_libLoading[name]) return _libLoading[name];
        const url = CDN_LIBS[name];
        if (!url) return Promise.reject(new Error('Unknown lib: ' + name));
        if (document.querySelector('script[src="' + url + '"]')) { _libLoading[name] = Promise.resolve(); return _libLoading[name]; }
        _libLoading[name] = new Promise((resolve, reject) => {
            const s = document.createElement('script');
            s.src = url;
            s.onload = resolve;
            s.onerror = () => reject(new Error(name + ' 載入失敗'));
            document.head.appendChild(s);
        });
        return _libLoading[name];
    }
    </script>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        :root {
            --bg: #f5f5f5; --bg-card: #fff; --text: #333; --text-secondary: #555;
            --text-muted: #666; --text-hint: #888; --text-placeholder: #999;
            --border: #e0e0e0; --border-light: #f0f0f0; --border-input: #ddd; --border-dotted: #eee;
            --hover-bg: #f0f6ff; --selected-bg: #e3f0ff;
            --cat-header-bg: linear-gradient(90deg, #e8f0fe, #fff);
            --table-header-bg: #f8f9fa; --table-border: #dee2e6;
            --qualified-bg: #e6f4ea; --qualified-text: #137333;
            --btn-light-bg: #e8eaed; --btn-light-text: #333;
            --input-bg: #fff; --score-input-bg: #fff;
        }
        [data-theme="dark"] {
            --bg: #1a1a2e; --bg-card: #16213e; --text: #e0e0e0; --text-secondary: #b0b0b0;
            --text-muted: #999; --text-hint: #777; --text-placeholder: #666;
            --border: #2a2a4a; --border-light: #252545; --border-input: #3a3a5a; --border-dotted: #2a2a4a;
            --hover-bg: #1e2a4a; --selected-bg: #1a2d5a;
            --cat-header-bg: linear-gradient(90deg, #1a2d5a, #16213e);
            --table-header-bg: #1a2d5a; --table-border: #3a3a5a;
            --qualified-bg: #1a3a2a; --qualified-text: #4caf50;
            --btn-light-bg: #2a2a4a; --btn-light-text: #ccc;
            --input-bg: #1e1e3e; --score-input-bg: #1e1e3e;
        }
        body { font-family: "Microsoft JhengHei", "Segoe UI", Arial, sans-serif; background: var(--bg); color: var(--text); transition: background 0.3s, color 0.3s; }

        /* Header */
        .header { background: linear-gradient(135deg, #1a73e8, #0d47a1); color: #fff; padding: 16px 24px; display: flex; align-items: center; gap: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); flex-wrap: wrap; }
        .header h1 { font-size: 22px; font-weight: 700; }
        .header span { font-size: 13px; opacity: 0.8; }
        .header-right { display: flex; align-items: center; gap: 8px; margin-left: auto; }

        /* Event title inline edit */
        .event-title-input { font-size: 20px; font-weight: 700; font-family: inherit; background: rgba(255,255,255,0.15); border: 1.5px solid rgba(255,255,255,0.4); color: #fff; padding: 4px 10px; border-radius: 6px; width: min(280px, 60vw); }
        .event-title-input::placeholder { color: rgba(255,255,255,0.5); }

        /* Theme toggle */
        .theme-toggle { margin-left: auto; background: rgba(255,255,255,0.15); border: 1.5px solid rgba(255,255,255,0.3); color: #fff; padding: 6px 14px; border-radius: 20px; cursor: pointer; font-size: 13px; font-weight: 600; transition: all 0.2s; display: flex; align-items: center; gap: 6px; }
        .theme-toggle:hover { background: rgba(255,255,255,0.25); }
        .theme-toggle .icon { font-size: 16px; }

        /* Tabs */
        .tabs { display: flex; background: var(--bg-card); border-bottom: 2px solid var(--border); }
        .tab-btn { flex: 1; padding: 14px; text-align: center; cursor: pointer; font-size: 15px; font-weight: 600; border: none; background: none; color: var(--text-muted); transition: all 0.2s; position: relative; }
        .tab-btn:hover { color: #1a73e8; background: var(--hover-bg); }
        .tab-btn.active { color: #1a73e8; }
        .tab-btn.active::after { content: ''; position: absolute; bottom: -2px; left: 0; right: 0; height: 3px; background: #1a73e8; }
        .tab-content { display: none; padding: 20px; max-width: 1200px; margin: 0 auto; }
        .tab-content.active { display: block; }

        /* Cards */
        .card { background: var(--bg-card); border-radius: 10px; padding: 20px; margin-bottom: 16px; box-shadow: 0 1px 4px rgba(0,0,0,0.08); }
        .card h3 { font-size: 16px; margin-bottom: 12px; color: #1a73e8; }

        /* Form elements */
        label { font-weight: 600; font-size: 14px; display: block; margin-bottom: 4px; color: var(--text-secondary); }
        input[type="text"], input[type="number"], select, textarea {
            width: 100%; padding: 10px 12px; border: 1.5px solid var(--border-input); border-radius: 6px;
            font-size: 16px; font-family: inherit; transition: border-color 0.2s;
            background: var(--input-bg); color: var(--text);
        }
        input:focus, textarea:focus, select:focus { outline: 2px solid #1a73e8; outline-offset: -1px; border-color: #1a73e8; box-shadow: 0 0 0 3px rgba(26,115,232,0.1); }
        input:focus:not(:focus-visible), textarea:focus:not(:focus-visible), select:focus:not(:focus-visible) { outline: none; }
        textarea { resize: vertical; min-height: 120px; }

        /* Buttons */
        .btn { padding: 12px 20px; border: none; border-radius: 6px; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; justify-content: center; gap: 6px; min-height: 44px; }
        .btn:hover { transform: translateY(-1px); box-shadow: 0 2px 8px rgba(0,0,0,0.15); }
        .btn:active { transform: translateY(0); }
        .btn-primary { background: #1a73e8; color: #fff; }
        .btn-success { background: #34a853; color: #fff; }
        .btn-warning { background: #f9ab00; color: #333; }
        .btn-danger { background: #ea4335; color: #fff; }
        .btn-light { background: var(--btn-light-bg); color: var(--btn-light-text); }
        [data-theme="dark"] .btn-warning { background: #e09600; color: #fff; }
        [data-theme="dark"] .toast.warning { background: #e09600; color: #fff; }
        .btn-lg { padding: 14px 28px; font-size: 16px; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

        /* Radio */
        .radio-group { display: flex; gap: 16px; margin: 8px 0; }
        .radio-group label { display: flex; align-items: center; gap: 6px; cursor: pointer; font-weight: 400; }

        /* Setup layout */
        .setup-layout { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
        @media (max-width: 768px) { .setup-layout { grid-template-columns: 1fr; gap: 12px; } }

        /* Pool list */
        .pool-list { list-style: none; max-height: min(300px, 40vh); overflow-y: auto; border: 1.5px solid var(--border); border-radius: 6px; }
        .pool-item { padding: 12px 16px; border-bottom: 1px solid var(--border-light); display: flex; justify-content: space-between; align-items: center; cursor: pointer; transition: background 0.15s; }
        .pool-item:hover { background: var(--hover-bg); }
        .pool-item.selected { background: var(--selected-bg); border-left: 3px solid #1a73e8; }
        .pool-item .info { font-weight: 600; }
        .pool-item .count { color: var(--text-hint); font-size: 13px; }

        /* Scoring */
        .category-header { background: var(--cat-header-bg); padding: 12px 16px; border-radius: 8px; margin-bottom: 12px; border-left: 4px solid #1a73e8; }
        .category-header h3 { color: #1a73e8; margin: 0; }
        .group-card { background: var(--bg-card); border: 1.5px solid var(--border); border-radius: 8px; padding: 16px; margin-bottom: 12px; }
        .group-card h4 { font-size: 15px; color: var(--text); margin-bottom: 10px; padding-bottom: 8px; border-bottom: 1px solid var(--border-dotted); }
        .match-row { display: flex; align-items: center; gap: 8px; padding: 8px 0; border-bottom: 1px dotted var(--border-dotted); flex-wrap: nowrap; }
        .match-row:last-child { border-bottom: none; }
        .match-no { background: #ea4335; color: #fff; font-size: 12px; font-weight: 700; width: 28px; height: 28px; border-radius: 50%; display: flex; align-items: center; justify-content: center; flex-shrink: 0; }
        .player-name { font-weight: 600; min-width: 0; flex: 1; text-align: right; font-size: 14px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .player-name.right { text-align: left; }
        .match-row .score-input, input.score-input[type="number"] { width: 70px; flex-shrink: 0; text-align: center; font-weight: 700; font-size: 16px; padding: 6px 4px; background: var(--score-input-bg); color: var(--text); border: 1.5px solid var(--border-input); border-radius: 6px; }
        .vs-label { font-weight: 700; color: var(--text-placeholder); font-size: 13px; flex-shrink: 0; }
        .ff-badge { display: inline-block; font-size: 13px; font-weight: 700; min-width: 28px; height: 28px; line-height: 28px; text-align: center; border-radius: 4px; cursor: pointer; user-select: none; vertical-align: middle; margin: 0 2px; padding: 0 4px; position: relative; }
        .ff-badge::before { content: ''; position: absolute; top: -6px; bottom: -6px; left: -6px; right: -6px; }
        .ff-badge[data-ff=""] { color: var(--text-placeholder); opacity: 0.5; border: 1px dashed var(--border-input); }
        .ff-badge[data-ff="injury"] { background: #fff3e0; color: #e67e00; border: 1px solid #e67e00; opacity: 1; }
        .ff-badge[data-ff="voluntary"] { background: #fde8e8; color: #ea4335; border: 1px solid #ea4335; opacity: 1; }
        .match-row.has-forfeit .player-name.forfeited-injury { color: #e67e00; }
        .match-row.has-forfeit .player-name.forfeited-voluntary { text-decoration: line-through; color: var(--text-placeholder); }
        .match-row.has-forfeit .score-input.forfeited-voluntary { opacity: 0.4; }
        /* H5: Hide number spinner */
        .score-input::-webkit-outer-spin-button, .score-input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .score-input { -moz-appearance: textfield; }
        .bracket-score::-webkit-outer-spin-button, .bracket-score::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
        .bracket-score { -moz-appearance: textfield; }

        /* Control bar */
        .control-bar { display: flex; gap: 10px; flex-wrap: wrap; padding: 16px; background: var(--bg-card); border-radius: 10px; margin-bottom: 16px; box-shadow: 0 1px 4px rgba(0,0,0,0.08); align-items: center; }
        .control-bar .title { font-weight: 700; font-size: 16px; margin-right: auto; }
        .ctrl-primary { width: 100%; }
        .ctrl-primary .btn { width: 100%; font-size: 15px; padding: 14px; }
        .ctrl-group { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
        .ctrl-group .file-input-wrapper { display: inline-flex; }

        /* Finals */
        .finals-list { list-style: none; border: 1.5px solid var(--border); border-radius: 6px; max-height: 400px; overflow-y: auto; }
        .finals-item { padding: 14px 16px; border-bottom: 1px solid var(--border-light); display: flex; align-items: center; gap: 10px; font-size: 16px; }
        .finals-item .rank { background: #f9ab00; color: #fff; width: 30px; height: 30px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: 700; flex-shrink: 0; }

        /* Finals category tabs */
        .finals-cat-bar { display: flex; gap: 0; margin-bottom: 16px; border-bottom: 2px solid var(--border); overflow-x: auto; background: var(--bg-card); border-radius: 10px 10px 0 0; padding: 0 8px; }
        .finals-cat-tab { padding: 10px 18px; font-size: 14px; font-weight: 600; cursor: pointer; border: none; background: none; color: var(--text-muted); position: relative; white-space: nowrap; transition: color 0.2s; font-family: inherit; }
        .finals-cat-tab:hover { color: #1a73e8; background: var(--hover-bg, rgba(26,115,232,0.06)); }
        .finals-cat-tab.active { color: #1a73e8; }
        .finals-cat-tab.active::after { content: ''; position: absolute; bottom: -2px; left: 0; right: 0; height: 3px; background: #1a73e8; border-radius: 3px 3px 0 0; }
        .cat-status { font-size: 11px; margin-left: 6px; padding: 2px 6px; border-radius: 10px; font-weight: 400; }
        .cat-status.done { background: var(--qualified-bg); color: var(--qualified-text); }
        .cat-status.in-progress { background: #fff3e0; color: #e65100; }
        [data-theme="dark"] .cat-status.in-progress { background: #3e2a10; color: #ffb74d; }
        .overview-table { width: 100%; border-collapse: collapse; }
        .overview-table th { background: var(--table-header-bg, #f5f5f5); padding: 10px 12px; text-align: left; font-size: 13px; font-weight: 700; border-bottom: 2px solid var(--border); }
        .overview-table td { padding: 10px 12px; border-bottom: 1px solid var(--border-light, #eee); font-size: 14px; }
        .overview-table tr:hover td { background: var(--hover-bg, rgba(26,115,232,0.04)); }
        [data-theme="dark"] .overview-table th { background: var(--table-header-bg); }

        /* Bracket (single elimination) */
        .bracket { overflow-x: auto; padding: 20px 0; position: relative; }
        .bracket::after { content: '← 滑動查看 →'; position: sticky; right: 0; bottom: 0; display: block; text-align: center; font-size: 12px; color: var(--text-placeholder); padding: 4px; opacity: 0.7; pointer-events: none; }
        .bracket-round { display: inline-flex; flex-direction: column; justify-content: center; gap: 20px; vertical-align: top; margin-right: 40px; min-width: 220px; }
        .bracket-round h4 { text-align: center; color: var(--text-hint); margin-bottom: 8px; font-size: 13px; }
        .bracket-match { background: var(--bg-card); border: 1.5px solid var(--border-input); border-radius: 8px; overflow: hidden; position: relative; }
        .bracket-slot { padding: 10px 12px; font-size: 15px; font-weight: 600; display: flex; justify-content: space-between; align-items: center; gap: 6px; }
        .bracket-slot:first-child { border-bottom: 1px solid var(--border-dotted); }
        .bracket-slot.winner { background: var(--qualified-bg); color: var(--qualified-text); }
        .bracket-slot .seed { color: var(--text-placeholder); font-size: 11px; }
        .bracket-player-name { flex: 1; min-width: 0; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .bracket-score { width: 52px; padding: 6px 4px; text-align: center; font-size: 14px; font-weight: 700; border: 1.5px solid var(--border-input); border-radius: 6px; background: var(--score-input-bg); color: var(--text); flex-shrink: 0; }
        .bracket-score::placeholder { font-size: 10px; font-weight: 400; color: var(--text-placeholder); }
        .bracket-score:disabled { opacity: 0.3; }
        .bracket-confirm { display: block; width: 100%; padding: 6px; font-size: 13px; font-weight: 600; border: none; background: linear-gradient(90deg, #1a73e8, #4285f4); color: #fff; cursor: pointer; transition: opacity 0.2s; min-height: 36px; }
        .bracket-confirm:hover { opacity: 0.85; }
        .bracket-confirm:disabled { background: var(--btn-light-bg); color: var(--text-muted); cursor: default; opacity: 0.5; }
        .bracket-result-card { background: var(--bg-card); border: 2px solid #f9ab00; border-radius: 10px; padding: 20px; margin-top: 16px; text-align: center; }
        .bracket-result-card h3 { color: #f9ab00; margin-bottom: 12px; }
        .medal-row { display: flex; justify-content: center; gap: 24px; flex-wrap: wrap; }
        .medal-item { text-align: center; padding: 12px 20px; border-radius: 8px; min-width: 120px; }
        .medal-item.gold { background: linear-gradient(135deg, #fff8e1, #ffecb3); border: 1.5px solid #f9ab00; }
        .medal-item.silver { background: linear-gradient(135deg, #f5f5f5, #e0e0e0); border: 1.5px solid #9e9e9e; }
        .medal-item.bronze { background: linear-gradient(135deg, #fbe9e7, #ffccbc); border: 1.5px solid #bf360c; }
        [data-theme="dark"] .medal-item.gold { background: linear-gradient(135deg, #5a4d10, #7a6c20); border-color: #c9a000; color: #fff; }
        [data-theme="dark"] .medal-item.silver { background: linear-gradient(135deg, #3a3a5a, #5a5a7a); border-color: #8a8aaa; color: #fff; }
        [data-theme="dark"] .medal-item.bronze { background: linear-gradient(135deg, #5a3820, #7a4c30); border-color: #c06020; color: #fff; }
        [data-theme="dark"] .medal-label { color: rgba(255,255,255,0.7); }
        .medal-label { font-size: 12px; color: var(--text-muted); margin-bottom: 4px; }
        .medal-name { font-size: 16px; font-weight: 700; }
        .result-print-btn { margin-top: 16px; }

        /* Progress panel */
        .progress-panel { background: var(--bg-card); border-radius: 10px; padding: 14px 18px; margin-bottom: 16px; box-shadow: 0 1px 4px rgba(0,0,0,0.08); }
        .progress-summary { display: flex; justify-content: space-between; align-items: center; font-size: 14px; margin-bottom: 8px; }
        .progress-bar-outer { height: 20px; background: var(--border); border-radius: 10px; overflow: hidden; margin-bottom: 10px; position: relative; }
        .progress-bar-inner { height: 100%; background: linear-gradient(90deg, #1a73e8, #34a853); border-radius: 10px; transition: width 0.4s ease; width: 0; display: flex; align-items: center; justify-content: flex-end; min-width: 0; }
        .progress-bar-text { position: absolute; top: 0; left: 0; right: 0; bottom: 0; display: flex; align-items: center; justify-content: center; font-size: 11px; font-weight: 700; color: var(--text); pointer-events: none; }
        .progress-detail { display: flex; flex-wrap: wrap; gap: 6px 12px; font-size: 13px; color: var(--text-secondary); }
        .progress-group { display: inline-flex; align-items: center; gap: 4px; }
        .progress-group.done { color: var(--qualified-text); font-weight: 600; }

        /* Toast */
        .toast { position: fixed; top: 20px; top: max(20px, env(safe-area-inset-top, 0px)); right: 20px; background: #333; color: #fff; padding: 12px 20px; border-radius: 8px; font-size: 14px; font-weight: 600; z-index: 1000; opacity: 0; transform: translateY(-10px); transition: all 0.3s; pointer-events: none; max-width: calc(100vw - 40px); box-shadow: 0 4px 12px rgba(0,0,0,0.25); }
        .toast.show { opacity: 1; transform: translateY(0); }
        .toast.success { background: #34a853; }
        .toast.error { background: #ea4335; }
        .toast.info { background: #1a73e8; }
        .toast.warning { background: #f9ab00; color: #333; }
        @media (max-width: 480px) { .toast { top: auto; bottom: 20px; bottom: max(20px, env(safe-area-inset-bottom, 0px)); right: 12px; left: 12px; max-width: none; text-align: center; } }

        /* File input */
        .file-input-wrapper { position: relative; }
        .file-input-wrapper input[type="file"] { position: absolute; opacity: 0; width: 100%; height: 100%; cursor: pointer; }

        /* Standings table */
        .standings-table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 13px; }
        .standings-table th { background: var(--table-header-bg); padding: 8px; text-align: left; font-weight: 600; border-bottom: 2px solid var(--table-border); color: var(--text); }
        .standings-table td { padding: 8px; border-bottom: 1px solid var(--border-dotted); color: var(--text); }
        .standings-table tr.qualified { background: var(--qualified-bg); }
        .standings-table tr.qualified td:first-child::before { content: ''; margin-right: 4px; }
        .standings-table tr.tied { background: #fff8e1; }
        [data-theme="dark"] .standings-table tr.tied { background: #4a4520; border-left: 3px solid #e67e00; }
        .tie-warn { color: #e67e00; font-weight: 600; font-size: 13px; margin: 8px 0; }
        .tie-check { width: 16px; height: 16px; cursor: pointer; accent-color: #1a73e8; }

        /* Empty state */
        .empty-state { text-align: center; padding: 60px 20px; color: var(--text-placeholder); }
        .empty-state .icon { font-size: 48px; margin-bottom: 12px; font-family: 'Apple Color Emoji', 'Segoe UI Emoji', 'Noto Color Emoji', sans-serif; line-height: 1.2; }
        .empty-state p { font-size: 15px; }

        /* Action bar */
        .action-bar { display: flex; gap: 8px; margin-top: 12px; flex-wrap: wrap; }
        .btn-group { display: flex; gap: 4px; }

        /* ===== Tablet (≤768px) ===== */
        @media (max-width: 768px) {
            .tab-content { padding: 16px 12px; }
            .card { padding: 16px; }
            .header { padding: 12px 16px; }
            .header h1 { font-size: 18px; }
            .control-bar { padding: 12px; gap: 8px; }
            .control-bar .title { width: 100%; margin-bottom: 4px; }
            .empty-state { padding: 40px 16px; }
            .pool-list { max-height: min(220px, 35vh); }
            .finals-list { max-height: 280px; }
            .bracket-round { margin-right: 20px; min-width: 180px; }
            .standings-table th, .standings-table td { padding: 6px 4px; font-size: 12px; }
            .action-bar .btn { flex: 1 1 calc(50% - 4px); }
        }

        /* ===== Mobile (≤480px) ===== */
        @media (max-width: 480px) {
            .header { padding: 10px 12px; gap: 8px; }
            .header h1 { font-size: 16px; }
            .header span { font-size: 11px; }
            .header-right { flex-wrap: wrap; gap: 4px; justify-content: flex-end; }
            .header-btn { font-size: 12px; padding: 5px 8px; }
            .theme-toggle { padding: 5px 10px; font-size: 12px; }
            .tab-btn { padding: 12px 6px; font-size: 13px; }
            .tab-content { padding: 10px 6px; }
            .card { padding: 12px; margin-bottom: 10px; }
            .card h3 { font-size: 15px; }
            textarea { min-height: 80px; }

            /* Control bar → grouped layout */
            .control-bar { padding: 10px; gap: 8px; }
            .control-bar .title { width: 100%; font-size: 15px; margin: 0 0 4px 0; }
            .control-bar #saveIndicator { width: 100%; }
            .ctrl-primary { margin-bottom: 4px; }
            .ctrl-primary .btn { font-size: 14px; padding: 12px; }
            .ctrl-group { gap: 6px; padding: 6px 0; border-top: 1px solid var(--border-dotted); width: 100%; }
            .ctrl-group .btn { flex: 1 1 calc(50% - 3px); font-size: 13px; padding: 10px 6px; }
            .ctrl-group .file-input-wrapper { flex: 1 1 calc(50% - 3px); }
            .ctrl-group .file-input-wrapper .btn { width: 100%; }

            /* Action bar → 2-col grid */
            .action-bar { gap: 6px; }
            .action-bar .btn { flex: 1 1 calc(50% - 3px); font-size: 13px; padding: 10px 6px; }

            /* M4: Progress detail collapse on mobile */
            .progress-detail { font-size: 12px; max-height: 60px; overflow: hidden; position: relative; }
            .progress-detail.expanded { max-height: none; }
            .progress-toggle { display: block; text-align: center; font-size: 12px; color: #1a73e8; cursor: pointer; padding: 4px; }

            /* Match row */
            .match-row { gap: 6px; padding: 10px 0; }
            .match-row .score-input, input.score-input[type="number"] { width: 56px; font-size: 16px; padding: 8px 4px; }
            .player-name { min-width: 0; flex: 1; font-size: 13px; }
            .vs-label { font-size: 12px; }
            .match-no { width: 24px; height: 24px; font-size: 11px; }

            /* Group card */
            .group-card { padding: 10px; }
            .group-card h4 { font-size: 13px; }
            .category-header { padding: 10px 12px; }

            /* Pool & Finals lists */
            .pool-list { max-height: min(180px, 30vh); }
            .pool-item { padding: 10px 12px; }
            .finals-list { max-height: 200px; }
            .finals-item { padding: 10px 12px; font-size: 14px; }
            .finals-item .rank { width: 26px; height: 26px; font-size: 12px; }

            /* Bracket */
            .bracket-round { margin-right: 16px; min-width: 130px; gap: 12px; }
            .bracket-slot { padding: 8px 10px; font-size: 14px; }

            /* Standings table — keep readable on mobile */
            .standings-table { font-size: 12px; display: block; overflow-x: auto; -webkit-overflow-scrolling: touch; }
            .standings-table thead, .standings-table tbody, .standings-table tr { display: table; width: 100%; table-layout: auto; }
            .standings-table th, .standings-table td { padding: 6px 4px; white-space: nowrap; }
            .tie-check { width: 22px; height: 22px; }

            /* Setup */
            .setup-layout { gap: 12px; }
            .radio-group { gap: 10px; }
            .btn-lg { padding: 12px 20px; font-size: 15px; }
        }

        /* Search */
        .search-input { width: 100%; padding: 10px 12px 10px 36px; border: 1.5px solid var(--border-input); border-radius: 20px; font-size: 14px; background: var(--score-input-bg) url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='%23999' viewBox='0 0 16 16'%3E%3Cpath d='M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85zm-5.242.156a5 5 0 1 1 0-10 5 5 0 0 1 0 10z'/%3E%3C/svg%3E") no-repeat 12px center; color: var(--text); outline: none; transition: border-color 0.2s; }
        .search-input:focus { border-color: #1a73e8; }
        .search-highlight { background: #fff3cd; outline: 2px solid #f9ab00; border-radius: 3px; }

        /* Modal overlay */
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; z-index: 2000; }
        .modal-card { background: var(--bg-card); border-radius: 12px; padding: 24px; max-width: 400px; width: 90%; box-shadow: 0 8px 32px rgba(0,0,0,0.2); position: relative; max-height: 80vh; overflow-y: auto; }
        .modal-card h3 { margin-bottom: 16px; font-size: 18px; }
        .modal-close { position: absolute; top: 12px; right: 12px; font-size: 24px; cursor: pointer; color: var(--text-muted); background: none; border: none; line-height: 1; width: 36px; height: 36px; display: flex; align-items: center; justify-content: center; border-radius: 6px; transition: background 0.15s; }
        .modal-close:hover { background: var(--hover-bg); color: var(--text); }
        .modal-close:focus { outline: 2px solid #1a73e8; outline-offset: 1px; }

        /* QR Code */
        .qr-container { text-align: center; }
        .qr-container img, .qr-container table { margin: 0 auto; }
        .qr-url { font-size: 12px; color: var(--text-hint); word-break: break-all; margin: 12px 0; }

        /* Share button in header */
        .header-btn { background: rgba(255,255,255,0.15); border: 1.5px solid rgba(255,255,255,0.3); color: #fff; padding: 6px 12px; border-radius: 20px; cursor: pointer; font-size: 13px; font-weight: 600; transition: all 0.2s; }
        .header-btn:hover { background: rgba(255,255,255,0.25); }

        /* Screenshot button */
        .screenshot-btn { font-size: 13px; padding: 6px 12px; background: var(--btn-light-bg); color: var(--btn-light-text); border: none; border-radius: 6px; cursor: pointer; font-weight: 600; }
        .screenshot-btn:hover { opacity: 0.8; }

        /* Event manager modal */
        .event-list { list-style: none; margin: 12px 0; }
        .event-item { display: flex; align-items: center; gap: 8px; padding: 10px; border: 1px solid var(--border); border-radius: 6px; margin-bottom: 6px; }
        .event-item.active { border-color: #1a73e8; background: var(--selected-bg); }
        .event-item .event-info { flex: 1; min-width: 0; }
        .event-item .event-name { font-weight: 600; font-size: 14px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .event-item .event-time { font-size: 11px; color: var(--text-hint); }
        .event-item .event-badge { font-size: 11px; background: #1a73e8; color: #fff; padding: 2px 8px; border-radius: 10px; }
        .event-item button { padding: 4px 10px; font-size: 12px; border: 1px solid var(--border); border-radius: 4px; cursor: pointer; background: var(--btn-light-bg); color: var(--btn-light-text); }
        .event-item button.del { color: #ea4335; border-color: #ea4335; }
    </style>
    <script>const APP_VERSION = 'v1.35';</script>
</head>
<body>

<div class="header">
    <h1 id="eventTitle" title="點擊編輯賽事名稱" onclick="editEventTitle()" style="cursor:pointer;">羽球賽務系統 <span style="font-size:14px;opacity:0.6;font-weight:400;">&#9998;</span></h1>
    <input type="text" id="eventTitleInput" class="event-title-input" style="display:none;" placeholder="輸入賽事名稱" maxlength="40">
    <span id="versionLabel"></span>
    <div class="header-right">
        <button class="header-btn" onclick="clearCurrentData()" title="清除目前賽事資料">&#128465; 清除</button>
        <button class="header-btn" onclick="showEventManager()" title="切換賽事">&#128203; 賽事</button>
        <button class="header-btn" onclick="showQRCode()" title="QR Code 分享">&#128279; 分享</button>
        <button class="theme-toggle" onclick="toggleTheme()">
            <span class="icon" id="themeIcon">&#9790;</span>
            <span id="themeLabel">Dark</span>
        </button>
    </div>
</div>

<div class="tabs" role="tablist">
    <button class="tab-btn active" id="btn-setup" role="tab" aria-selected="true" aria-controls="tab-setup" tabindex="0" onclick="switchTab('setup')">1. 名單設定</button>
    <button class="tab-btn" id="btn-scoring" role="tab" aria-selected="false" aria-controls="tab-scoring" tabindex="-1" onclick="switchTab('scoring')">2. 預賽計分</button>
    <button class="tab-btn" id="btn-finals" role="tab" aria-selected="false" aria-controls="tab-finals" tabindex="-1" onclick="switchTab('finals')">3. 決賽</button>
</div>

<!-- Tab 1: Setup -->
<div id="tab-setup" class="tab-content active" role="tabpanel" aria-labelledby="btn-setup">
    <div class="setup-layout">
        <div>
            <div class="card">
                <h3>步驟一：匯入或手動輸入名單</h3>
                <div style="display: flex; gap: 8px; margin-bottom: 16px;">
                    <div class="file-input-wrapper" style="flex: 1;">
                        <button class="btn btn-warning" style="width:100%; position:relative;">
                            Excel 批次匯入
                            <input type="file" id="excelFile" accept=".xlsx,.xls" onchange="importExcel(event)">
                        </button>
                    </div>
                    <button class="btn btn-light" onclick="downloadTemplate()">下載範本</button>
                </div>
                <hr style="margin: 16px 0; border: none; border-top: 1px solid var(--border);">
                <div style="margin-bottom: 12px;">
                    <label>類別名稱（例：3男單）</label>
                    <input type="text" id="catName" placeholder="輸入類別名稱">
                </div>
                <div class="radio-group">
                    <label><input type="radio" name="matchType" value="單打" checked> 單打</label>
                    <label><input type="radio" name="matchType" value="雙打"> 雙打</label>
                </div>
                <div style="margin-bottom: 12px;">
                    <label>名單（每行一位，格式：學校 姓名）</label>
                    <textarea id="playerList" placeholder="範例：&#10;北一女 王小明&#10;建中 李小華&#10;師大附中 陳小美"></textarea>
                </div>
                <button class="btn btn-primary" style="width:100%;" onclick="addToPool()">加入 / 儲存修改</button>
            </div>
        </div>
        <div>
            <div class="card">
                <h3>步驟二：確認暫存池</h3>
                <ul class="pool-list" id="poolList">
                    <li class="empty-state" id="poolEmpty">
                        <div class="icon">&#127992;</div>
                        <p>尚無任何名單，請先新增</p>
                    </li>
                </ul>
                <div class="action-bar" id="poolActions" style="display:none;">
                    <button class="btn btn-light" onclick="loadPoolItem()">載入編輯</button>
                    <button class="btn btn-danger" onclick="deletePoolItem()">刪除選取</button>
                    <button class="btn btn-danger" onclick="clearAllPool()" style="margin-left:auto;">全部清空</button>
                </div>
            </div>
            <button class="btn btn-success btn-lg" style="width:100%; margin-top: 8px;" onclick="startTournament()" title="自動處理 5 人三角 + 直線分組">
                智慧分組
            </button>
        </div>
    </div>
</div>

<!-- Tab 2: Scoring -->
<div id="tab-scoring" class="tab-content" role="tabpanel" aria-labelledby="btn-scoring">
    <div style="margin-bottom:8px;">
        <input type="search" id="playerSearch" class="search-input" placeholder="搜尋選手姓名..." aria-label="搜尋選手">
    </div>
    <div class="control-bar">
        <span class="title">預賽控制台</span>
        <span id="saveIndicator" role="status" aria-live="polite" style="font-size:12px;color:var(--text-hint);"></span>
        <div class="ctrl-group">
            <button class="btn btn-light" id="undoBtn" onclick="undo()" disabled title="復原 (Ctrl+Z)">&#x21A9;&#xFE0E; 復原</button>
            <button class="btn btn-light" id="redoBtn" onclick="redo()" disabled title="重做 (Ctrl+Y)">&#x21AA;&#xFE0E; 重做</button>
            <button class="btn btn-success" onclick="saveToExcel()">存檔</button>
            <div class="file-input-wrapper">
                <button class="btn btn-light" style="position:relative;">載入存檔
                    <input type="file" accept=".xlsx,.xls" onchange="loadFromExcel(event)">
                </button>
            </div>
            <button class="btn btn-light" onclick="exportJSON()" title="匯出 JSON 備份（不需網路）">JSON 備份</button>
            <div class="file-input-wrapper">
                <button class="btn btn-light" style="position:relative;" title="匯入 JSON 備份">載入備份
                    <input type="file" accept=".json" onchange="importJSON(event)">
                </button>
            </div>
        </div>
        <div class="ctrl-group">
            <button class="btn btn-warning" onclick="generateExcel()">下載成績</button>
            <button class="btn btn-light" onclick="exportCSV()">CSV</button>
            <button class="btn btn-light" onclick="generateFullReport()">綜合報表</button>
            <button class="btn btn-light" onclick="openChartView()">列印對戰圖</button>
            <button class="btn btn-light" onclick="generatePrelimSheets()">出賽單</button>
            <button class="btn btn-light" onclick="captureScreenshot('scoringArea')">截圖</button>
        </div>
        <div class="ctrl-primary">
            <button class="btn btn-primary" id="promoteBtn" onclick="promoteWinners()">結算冠軍 → 送入決賽區</button>
        </div>
    </div>
    <div id="progressPanel" class="progress-panel" role="status" aria-live="polite" style="display:none">
        <div class="progress-summary">
            <span>整體進度：<strong id="progressPct">0%</strong></span>
            <span>已完成 <strong id="progressDone">0</strong> / <strong id="progressTotal">0</strong> 場</span>
        </div>
        <div class="progress-bar-outer"><div class="progress-bar-inner" id="progressBar"></div><div class="progress-bar-text" id="progressBarText"></div></div>
        <div id="progressDetail"></div>
    </div>
    <div id="scoringArea">
        <div class="empty-state">
            <div class="icon">&#127941;</div>
            <p>尚未開始賽事，請先至「名單設定」完成分組</p>
        </div>
    </div>
</div>

<!-- Tab 3: Finals -->
<div id="tab-finals" class="tab-content" role="tabpanel" aria-labelledby="btn-finals">
    <!-- Category tab bar -->
    <div id="finalsCategoryBar" class="finals-cat-bar" style="display:none;"></div>

    <!-- Overview panel (全場總覽) -->
    <div id="finalsOverview" class="card" style="display:none;">
        <h3>全場總覽</h3>
        <div id="finalsOverviewContent"></div>
    </div>

    <!-- Per-category content -->
    <div id="finalsCategoryContent">
        <div class="card">
            <h3 id="finalsCatTitle">決賽單淘汰管理區</h3>
            <div style="margin-bottom: 12px;">
                <label>決賽標題</label>
                <input type="text" id="finalTitle" placeholder="輸入決賽標題">
            </div>
            <label>晉級名單</label>
            <ul class="finals-list" id="finalsList">
                <li class="empty-state" id="finalsEmpty">
                    <div class="icon">&#127942;</div>
                    <p>尚無晉級者，請先在預賽計分中結算冠軍</p>
                </li>
            </ul>
            <div class="action-bar" id="finalsActionBar" style="margin-top: 12px; flex-wrap: wrap;">
                <button class="btn btn-light" onclick="shuffleFinals()">抽籤</button>
                <button class="btn btn-success" onclick="generateBracket()">產生對戰圖</button>
                <button class="btn btn-primary" onclick="generateFinalsScoreTable()">對戰表</button>
                <button class="btn btn-danger" onclick="printFinalsBracketPDF()">列印對戰圖</button>
                <button class="btn btn-light" onclick="generateFinalsSheets()">出賽單</button>
                <button class="btn btn-warning" onclick="exportFinalsExcel()">下載 Excel</button>
                <button class="btn btn-light" onclick="captureScreenshot('bracketArea')">截圖</button>
            </div>
            <div class="action-bar" id="prelimActionBar" style="margin-top: 12px; flex-wrap: wrap; display: none;">
                <button class="btn btn-danger" onclick="printResultAnnouncement()">成績公告</button>
                <button class="btn btn-light" onclick="generateFullReport()">綜合報表</button>
            </div>
        </div>
        <div id="finalsScoreArea"></div>
        <div id="bracketArea"></div>
    </div>
</div>

<div class="toast" id="toast" role="status" aria-live="polite"></div>
<div id="modalOverlay" class="modal-overlay" style="display:none" onclick="if(event.target===this)closeModal()"></div>

<script>
// ╔══════════════════════════════════════════════════════════╗
// ║               目 錄 索 引 (Table of Contents)            ║
// ╠══════════════════════════════════════════════════════════╣
// ║  Theme .......................... ~L548                   ║
// ║  Modal helpers .................. ~L588                   ║
// ║  QR Code Sharing ............... ~L677                   ║
// ║  Screenshot Sharing ............ ~L710                   ║
// ║  Multi-Event Management ........ ~L737                   ║
// ║  Event Title ................... ~L978                   ║
// ║  State ......................... ~L1012                  ║
// ║  Global Constants .............. ~L1030                  ║
// ║  Shared Utility Functions ...... ~L1036                  ║
// ║  Multi-Category Finals Helpers . ~L1099                  ║
// ║  Undo / Redo ................... ~L1185                  ║
// ║  Persistence (localStorage) .... ~L1318                  ║
// ║  Progress Panel ................ ~L1552                  ║
// ║  Tab switching ................. ~L1649                  ║
// ║  Toast ......................... ~L1674                  ║
// ║  Tab 1: Setup .................. ~L1688                  ║
// ║  Tab 2: Smart grouping + scoring ~L1817                  ║
// ║  Tab 3: Finals — Tab Bar ....... ~L2313                  ║
// ║  Tab 3: Finals — Per-Category .. ~L2404                  ║
// ║  Combined Full Report .......... ~L2969                  ║
// ║  Match Sheets (出賽單) ......... ~L3339                  ║
// ║  Save / Load (.xlsx) ........... ~L3556                  ║
// ║  Excel export (成績報表) ....... ~L3668                  ║
// ║  Chart View — 對戰圖 (SVG) .... ~L3812                  ║
// ║  Utils ......................... ~L4257                  ║
// ║  Download template Excel ....... ~L4294                  ║
// ╚══════════════════════════════════════════════════════════╝

// ============================================================
// Theme
// ============================================================
(function() {
    const saved = localStorage.getItem('theme');
    if (saved === 'dark') document.documentElement.setAttribute('data-theme', 'dark');
})();

function toggleTheme() {
    const html = document.documentElement;
    const isDark = html.getAttribute('data-theme') === 'dark';
    if (isDark) {
        html.removeAttribute('data-theme');
        localStorage.setItem('theme', 'light');
    } else {
        html.setAttribute('data-theme', 'dark');
        localStorage.setItem('theme', 'dark');
    }
    updateThemeUI();
}

function updateThemeUI() {
    const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
    document.getElementById('themeIcon').innerHTML = isDark ? '&#9788;' : '&#9790;';
    document.getElementById('themeLabel').textContent = isDark ? '淺色' : '深色';
}

document.addEventListener('DOMContentLoaded', function() {
    // L1: Set version from constant
    document.title = '羽球賽務系統 ' + APP_VERSION;
    document.getElementById('versionLabel').textContent = APP_VERSION;
    updateThemeUI();
    migrateToMultiEvent();
    loadState();
    // Register Service Worker
    if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('./sw.js').catch(() => {});
    }
});

// ============================================================
// Modal helpers
// ============================================================
function closeModal() {
    const overlay = document.getElementById('modalOverlay');
    overlay.style.display = 'none';
    overlay.innerHTML = '';
}

// Custom prompt dialog (replaces native prompt)
function customPrompt(message, defaultValue) {
    return new Promise(resolve => {
        const overlay = document.getElementById('modalOverlay');
        const card = document.createElement('div');
        card.className = 'modal-card';
        card.setAttribute('role', 'dialog');
        card.setAttribute('aria-modal', 'true');
        const label = document.createElement('label');
        label.style.cssText = 'font-size:15px;margin-bottom:8px;display:block;';
        label.textContent = message;
        const input = document.createElement('input');
        input.type = 'text';
        input.value = defaultValue || '';
        input.style.cssText = 'width:100%;margin-bottom:16px;';
        const btnRow = document.createElement('div');
        btnRow.style.cssText = 'display:flex;gap:8px;justify-content:flex-end;';
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'btn btn-light';
        cancelBtn.textContent = '取消';
        const okBtn = document.createElement('button');
        okBtn.className = 'btn btn-primary';
        okBtn.textContent = '確定';
        btnRow.appendChild(cancelBtn);
        btnRow.appendChild(okBtn);
        card.appendChild(label);
        card.appendChild(input);
        card.appendChild(btnRow);
        overlay.innerHTML = '';
        overlay.appendChild(card);
        overlay.style.display = 'flex';
        input.focus();
        input.select();
        const submit = () => { const v = input.value.trim(); closeModal(); resolve(v || null); };
        okBtn.onclick = submit;
        cancelBtn.onclick = () => { closeModal(); resolve(null); };
        input.addEventListener('keydown', e => { if (e.key === 'Enter') submit(); });
    });
}

// M9: Escape key closes modal
document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
        const overlay = document.getElementById('modalOverlay');
        if (overlay && overlay.style.display !== 'none') closeModal();
    }
});

// M3: Custom confirm dialog (replaces native confirm)
function customConfirm(message) {
    return new Promise(resolve => {
        const overlay = document.getElementById('modalOverlay');
        const card = document.createElement('div');
        card.className = 'modal-card';
        card.setAttribute('role', 'dialog');
        card.setAttribute('aria-modal', 'true');
        const p = document.createElement('p');
        p.style.cssText = 'font-size:15px;margin-bottom:20px;line-height:1.6;';
        p.textContent = message;
        const btnRow = document.createElement('div');
        btnRow.style.cssText = 'display:flex;gap:8px;justify-content:flex-end;';
        const noBtn = document.createElement('button');
        noBtn.className = 'btn btn-light';
        noBtn.textContent = '取消';
        const yesBtn = document.createElement('button');
        yesBtn.className = 'btn btn-danger';
        yesBtn.textContent = '確定';
        btnRow.appendChild(noBtn);
        btnRow.appendChild(yesBtn);
        card.appendChild(p);
        card.appendChild(btnRow);
        overlay.innerHTML = '';
        overlay.appendChild(card);
        overlay.style.display = 'flex';
        yesBtn.focus();
        yesBtn.onclick = () => { closeModal(); resolve(true); };
        noBtn.onclick = () => { closeModal(); resolve(false); };
    });
}

// ============================================================
// QR Code Sharing
// ============================================================
async function showQRCode() {
    const url = location.href;
    const overlay = document.getElementById('modalOverlay');
    try { await loadLib('qrcode'); } catch(err) { showToast(err.message, 'error'); return; }
    let qrHtml = '';
    try {
        const qr = qrcode(0, 'M');
        qr.addData(url);
        qr.make();
        qrHtml = qr.createSvgTag(5, 0);
    } catch (e) {
        qrHtml = '<p style="color:var(--text-muted)">QR Code 產生失敗</p>';
    }
    overlay.innerHTML = `<div class="modal-card">
        <button class="modal-close" onclick="closeModal()" aria-label="關閉">&times;</button>
        <h3>分享此頁面</h3>
        <div class="qr-container">${qrHtml}</div>
        <div class="qr-url">${escapeXml(url)}</div>
        <button class="btn btn-primary" style="width:100%;" id="qrCopyBtn">複製連結</button>
    </div>`;
    overlay.style.display = 'flex';
    document.getElementById('qrCopyBtn').addEventListener('click', function() {
        navigator.clipboard.writeText(url).then(function() {
            showToast('已複製連結', 'success');
        }).catch(function() {
            showToast('複製失敗', 'error');
        });
    });
}

// ============================================================
// Screenshot Sharing
// ============================================================
async function captureScreenshot(elementId) {
    const el = document.getElementById(elementId);
    if (!el || !el.innerHTML.trim()) { showToast('尚無內容可截圖', 'error'); return; }
    try { await loadLib('html2canvas'); } catch(err) { showToast(err.message, 'error'); return; }
    showToast('截圖中...', 'info');
    html2canvas(el, { scale: 2, useCORS: true, backgroundColor: getComputedStyle(document.body).backgroundColor }).then(function(canvas) {
        canvas.toBlob(function(blob) {
            const fileName = (getEventTitle() + '_' + (elementId === 'scoringArea' ? '預賽' : '決賽') + '_' + new Date().toISOString().slice(0, 10) + '.png');
            // Try native share API (mobile)
            if (navigator.share && navigator.canShare && navigator.canShare({ files: [new File([blob], fileName, { type: 'image/png' })] })) {
                navigator.share({ files: [new File([blob], fileName, { type: 'image/png' })], title: getEventTitle() }).catch(() => {});
            } else {
                // Fallback: download
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = fileName;
                a.click();
                URL.revokeObjectURL(a.href);
            }
            showToast('截圖完成', 'success');
        }, 'image/png');
    }).catch(function() { showToast('截圖失敗', 'error'); });
}

// ============================================================
// Multi-Event Management
// ============================================================
function generateEventId() {
    return 'evt_' + Date.now().toString(36) + Math.random().toString(36).slice(2, 6);
}

function getEventList() {
    try {
        return JSON.parse(localStorage.getItem('badminton_events') || '[]');
    } catch { return []; }
}

function saveEventList(list) {
    localStorage.setItem('badminton_events', JSON.stringify(list));
}

function migrateToMultiEvent() {
    // First-time migration: if old state exists but no event list, wrap it as first event
    const list = getEventList();
    if (list.length > 0) return; // Already migrated
    const raw = localStorage.getItem('badminton_state');
    if (!raw) return; // No data to migrate
    try {
        const saved = JSON.parse(raw);
        const id = generateEventId();
        state.eventId = id;
        localStorage.setItem('badminton_event_' + id, raw);
        saveEventList([{ id, title: saved.eventTitle || '預設賽事', updatedAt: new Date().toISOString() }]);
    } catch {}
}

function saveCurrentEvent() {
    if (!state.eventId) {
        state.eventId = generateEventId();
    }
    const raw = localStorage.getItem('badminton_state');
    if (raw) localStorage.setItem('badminton_event_' + state.eventId, raw);
    // Update event list
    const list = getEventList();
    const idx = list.findIndex(e => e.id === state.eventId);
    const entry = { id: state.eventId, title: state.eventTitle || '未命名賽事', updatedAt: new Date().toISOString() };
    if (idx >= 0) list[idx] = entry;
    else list.push(entry);
    saveEventList(list);
}

function loadEvent(eventId) {
    const raw = localStorage.getItem('badminton_event_' + eventId);
    if (!raw) { showToast('找不到此賽事資料', 'error'); return; }
    // Save current first
    saveCurrentEvent();
    // Load target
    localStorage.setItem('badminton_state', raw);
    state.eventId = eventId;
    loadState();
    closeModal();
    showToast('已載入賽事', 'success');
}

function _resetTournamentUI(displayTitle) {
    const h1 = document.getElementById('eventTitle');
    if (h1) h1.textContent = displayTitle || '羽球賽務系統';
    document.title = (displayTitle || '羽球賽務系統') + ' ' + APP_VERSION;
    const ft = document.getElementById('finalTitle');
    if (ft) ft.value = '';
    refreshPoolList();
    document.getElementById('scoringArea').innerHTML = '<div class="empty-state"><div class="icon">&#127941;</div><p>尚未開始賽事，請先至「名單設定」完成分組</p></div>';
    document.getElementById('progressPanel').style.display = 'none';
    const catBar = document.getElementById('finalsCategoryBar');
    if (catBar) { catBar.style.display = 'none'; catBar.innerHTML = ''; }
    const fOverview = document.getElementById('finalsOverview');
    if (fOverview) fOverview.style.display = 'none';
    const fContent = document.getElementById('finalsCategoryContent');
    if (fContent) fContent.style.display = '';
    const fCatTitle = document.getElementById('finalsCatTitle');
    if (fCatTitle) fCatTitle.textContent = '決賽單淘汰管理區';
    renderFinalsList();
    document.getElementById('bracketArea').innerHTML = '';
    document.getElementById('finalsScoreArea').innerHTML = '';
}

function createNewEvent() {
    saveCurrentEvent();
    state.setupPool = {};
    state.activeGroups = {};
    state.finalQualifiers = {};
    state.manualQualify = {};
    state.bracketMatches = {};
    state.prelimBronze = {};
    state.prelimResults = {};
    state.activeCategory = null;
    state.eventTitle = '';
    state.selectedPoolItem = null;
    state.editingKey = null;
    state.eventId = generateEventId();
    undoStack.length = 0;
    redoStack.length = 0;
    _resetTournamentUI('羽球賽務系統');
    saveState();
    saveCurrentEvent();
    closeModal();
    switchTab('setup');
    showToast('已建立新賽事', 'success');
}

async function clearCurrentData() {
    if (!await customConfirm('確定要清除目前賽事的所有資料嗎？\n（名單、分組、比分、決賽結果都會被清除）')) return;
    const keepId = state.eventId;
    const keepTitle = state.eventTitle;
    state.setupPool = {};
    state.activeGroups = {};
    state.finalQualifiers = {};
    state.manualQualify = {};
    state.bracketMatches = {};
    state.prelimBronze = {};
    state.prelimResults = {};
    state.activeCategory = null;
    state.selectedPoolItem = null;
    state.editingKey = null;
    state.eventId = keepId;
    state.eventTitle = keepTitle;
    undoStack.length = 0;
    redoStack.length = 0;
    _resetTournamentUI(keepTitle);
    saveState();
    saveCurrentEvent();
    switchTab('setup');
    showToast('已清除所有賽事資料', 'success');
}

async function deleteEvent(eventId) {
    if (eventId === state.eventId) { showToast('無法刪除目前進行中的賽事', 'error'); return; }
    if (!await customConfirm('確定要刪除此賽事？此操作無法復原。')) return;
    localStorage.removeItem('badminton_event_' + eventId);
    const list = getEventList().filter(e => e.id !== eventId);
    saveEventList(list);
    showEventManager();
    showToast('已刪除', 'success');
}

function showEventManager() {
    saveCurrentEvent();
    const list = getEventList();
    const overlay = document.getElementById('modalOverlay');
    overlay.innerHTML = '';
    const card = document.createElement('div');
    card.className = 'modal-card';

    const closeBtn = document.createElement('button');
    closeBtn.className = 'modal-close';
    closeBtn.setAttribute('aria-label', '關閉');
    closeBtn.innerHTML = '&times;';
    closeBtn.onclick = closeModal;
    card.appendChild(closeBtn);

    const h3 = document.createElement('h3');
    h3.textContent = '賽事管理';
    card.appendChild(h3);

    const newBtn = document.createElement('button');
    newBtn.className = 'btn btn-success';
    newBtn.style.cssText = 'width:100%;margin-bottom:12px;';
    newBtn.textContent = '+ 新增賽事';
    newBtn.onclick = createNewEvent;
    card.appendChild(newBtn);

    const ul = document.createElement('ul');
    ul.className = 'event-list';

    if (list.length === 0) {
        const li = document.createElement('li');
        li.style.cssText = 'text-align:center;color:var(--text-hint);padding:20px;';
        li.textContent = '尚無已儲存的賽事';
        ul.appendChild(li);
    } else {
        list.sort((a, b) => (b.updatedAt || '').localeCompare(a.updatedAt || ''));
        list.forEach(evt => {
            const isActive = evt.id === state.eventId;
            const li = document.createElement('li');
            li.className = 'event-item' + (isActive ? ' active' : '');

            const info = document.createElement('div');
            info.className = 'event-info';
            const nameDiv = document.createElement('div');
            nameDiv.className = 'event-name';
            nameDiv.textContent = evt.title || '未命名賽事';
            const timeDiv = document.createElement('div');
            timeDiv.className = 'event-time';
            timeDiv.textContent = evt.updatedAt ? new Date(evt.updatedAt).toLocaleString() : '';
            info.appendChild(nameDiv);
            info.appendChild(timeDiv);
            li.appendChild(info);

            if (isActive) {
                const badge = document.createElement('span');
                badge.className = 'event-badge';
                badge.textContent = '進行中';
                li.appendChild(badge);
            } else {
                const loadBtn = document.createElement('button');
                loadBtn.textContent = '載入';
                loadBtn.onclick = () => loadEvent(evt.id);
                li.appendChild(loadBtn);
                const delBtn = document.createElement('button');
                delBtn.className = 'del';
                delBtn.textContent = '刪除';
                delBtn.onclick = () => deleteEvent(evt.id);
                li.appendChild(delBtn);
            }
            ul.appendChild(li);
        });
    }
    card.appendChild(ul);
    overlay.appendChild(card);
    overlay.style.display = 'flex';
}

// ============================================================
// Event Title
// ============================================================
function getEventTitle() {
    return state.eventTitle || '羽球賽務系統';
}
function editEventTitle() {
    const h1 = document.getElementById('eventTitle');
    const inp = document.getElementById('eventTitleInput');
    h1.style.display = 'none';
    inp.style.display = '';
    inp.value = state.eventTitle || '';
    inp.focus();
    inp.select();
}
function saveEventTitle() {
    const h1 = document.getElementById('eventTitle');
    const inp = document.getElementById('eventTitleInput');
    const val = inp.value.trim();
    state.eventTitle = val;
    h1.textContent = val || '羽球賽務系統';
    h1.style.display = '';
    inp.style.display = 'none';
    document.title = (val || '羽球賽務系統') + ' ' + APP_VERSION;
    saveState();
}
document.addEventListener('DOMContentLoaded', function() {
    const inp = document.getElementById('eventTitleInput');
    if (inp) {
        inp.addEventListener('blur', saveEventTitle);
        inp.addEventListener('keydown', function(e) { if (e.key === 'Enter') inp.blur(); });
    }
});

// ============================================================
// State
// ============================================================
const state = {
    setupPool: {},          // { catName: { type, players[] } }
    activeGroups: {},       // { catName: [ { name, members[], matches[] } ] }
    finalQualifiers: {},    // { catName: [ { label, name } ] }
    manualQualify: {},      // { "cat_gName": [idx, ...] } — manual tie-break selections
    bracketMatches: {},     // { catName: [ { id, round, matchIdx, p1, p2, s1, s2, winner } ] }
    prelimBronze: {},       // { catName: "playerName" } — 3-person group's 3rd place
    prelimResults: {},      // { catName: { champion, runnerUp, bronzes[], fourth, matches[] } } — results from single-group categories
    activeCategory: null,   // Currently selected category in finals tab
    eventTitle: '',         // Custom event title
    eventId: null,          // Multi-event ID
    selectedPoolItem: null,
    editingKey: null
};

// ============================================================
// Global Constants
// ============================================================
const ROUND_NAMES = ['第一輪', '第二輪', '八強', '四強', '準決賽', '決賽'];
const FF_TYPES = { NONE: '', INJURY: 'injury', VOLUNTARY: 'voluntary' };

// ============================================================
// Shared Utility Functions
// ============================================================

// Get both score elements + values for a match
function getMatchScores(matchId) {
    const s1El = document.getElementById('s1_' + matchId);
    const s2El = document.getElementById('s2_' + matchId);
    return {
        s1El, s2El,
        v1: s1El ? s1El.value : '',
        v2: s2El ? s2El.value : '',
        n1: s1El ? parseInt(s1El.value) : NaN,
        n2: s2El ? parseInt(s2El.value) : NaN
    };
}

// Badminton score rule check (non-blocking warnings)
function checkBadmintonScore(s1, s2) {
    if (isNaN(s1) || isNaN(s2) || s1 === '' || s2 === '') return;
    const a = parseInt(s1), b = parseInt(s2);
    if (isNaN(a) || isNaN(b)) return;
    if (a > 30 || b > 30) {
        showToast('提醒：分數超過 30 分上限', 'warning'); return;
    }
    if (a >= 20 && b >= 20) {
        const hi = Math.max(a, b), lo = Math.min(a, b);
        if (hi < 30 && hi - lo !== 2 && hi - lo !== 0) {
            showToast('提醒：20 平後需贏 2 分（如 22:20、23:21）', 'warning');
        }
    } else {
        const hi = Math.max(a, b), lo = Math.min(a, b);
        if (hi > 21) {
            showToast('提醒：正常比賽得分上限為 21 分', 'warning');
        }
    }
}

// Collect voluntary/injury players from a group's matches
function collectForfeitPlayers(group) {
    const voluntary = new Set();
    const injury = new Set();
    group.matches.forEach(m => {
        const f1 = getFF(m.matchId, 1);
        const f2 = getFF(m.matchId, 2);
        if (f1 === FF_TYPES.VOLUNTARY) voluntary.add(m.p1);
        if (f2 === FF_TYPES.VOLUNTARY) voluntary.add(m.p2);
        if (f1 === FF_TYPES.INJURY) injury.add(m.p1);
        if (f2 === FF_TYPES.INJURY) injury.add(m.p2);
    });
    return { voluntary, injury };
}

// Get bracket round count (excluding 3rd place match)
function getBracketRoundCount(matches) {
    if (!matches) return 0;
    const normal = matches.filter(m => !m.isThirdPlace);
    return normal.length > 0 ? Math.max(...normal.map(m => m.round)) + 1 : 0;
}

// Get round display name
function getRoundName(roundIndex, totalRounds) {
    const offset = totalRounds - roundIndex;
    return offset <= ROUND_NAMES.length ? ROUND_NAMES[ROUND_NAMES.length - offset] : '第 ' + (roundIndex + 1) + ' 輪';
}

// Detect tie at qualification boundary; returns { hasTie, tiedIndices }
function detectTiedGroup(ranked, nQualify) {
    const boundaryScore = ranked[nQualify - 1] ? ranked[nQualify - 1][1] : null;
    const tiedIndices = new Set();
    if (!boundaryScore) return { hasTie: false, tiedIndices };
    ranked.forEach(([idx, s], rank) => {
        if (sameRecord(s, boundaryScore)) tiedIndices.add(rank);
    });
    const tiedArr = [...tiedIndices];
    const minTied = Math.min(...tiedArr);
    const maxTied = Math.max(...tiedArr);
    if (minTied < nQualify && maxTied >= nQualify) {
        return { hasTie: true, tiedIndices };
    }
    tiedIndices.clear();
    return { hasTie: false, tiedIndices };
}

// ============================================================
// Multi-Category Finals Helpers
// ============================================================
function getCurrentFinalQualifiers() {
    if (!state.activeCategory) return [];
    return state.finalQualifiers[state.activeCategory] || [];
}

function getCurrentBracketMatches() {
    if (!state.activeCategory) return null;
    return state.bracketMatches[state.activeCategory] || null;
}

function setCurrentBracketMatches(matches) {
    if (!state.activeCategory) return;
    state.bracketMatches[state.activeCategory] = matches;
}

function hasFinalQualifiers() {
    return Object.keys(state.finalQualifiers).some(k => state.finalQualifiers[k] && state.finalQualifiers[k].length > 0);
}

function getFinalsCategories() {
    return Object.keys(state.finalQualifiers).filter(k => state.finalQualifiers[k] && state.finalQualifiers[k].length > 0);
}

function getBracketResultsForCategory(cat) {
    const matches = state.bracketMatches[cat];
    if (!matches || matches.length === 0) {
        // Fall back to prelim-only results for single-group categories
        return (state.prelimResults && state.prelimResults[cat]) || null;
    }
    const normalMatches = matches.filter(m => !m.isThirdPlace);
    if (normalMatches.length === 0) return null;
    const maxRound = Math.max(...normalMatches.map(m => m.round));
    const finalMatch = normalMatches.find(m => m.round === maxRound);
    if (!finalMatch || !finalMatch.winner) return null;
    const champion = finalMatch.winner;
    const runnerUp = finalMatch.winner === finalMatch.p1 ? finalMatch.p2 : finalMatch.p1;
    const thirdMatch = matches.find(m => m.isThirdPlace);
    let bronze = null, fourth = null, bronzes = [];
    if (thirdMatch && thirdMatch.winner) {
        bronze = thirdMatch.winner;
        fourth = thirdMatch.winner === thirdMatch.p1 ? thirdMatch.p2 : thirdMatch.p1;
        bronzes = [bronze];
    } else {
        const semiFinals = normalMatches.filter(m => m.round === maxRound - 1);
        bronzes = semiFinals.map(m => m.winner ? (m.winner === m.p1 ? m.p2 : m.p1) : null).filter(n => n && n !== '—BYE—' && n !== '—TBD—');
    }
    // Include prelim bronze (3rd place from 3-person group)
    if (bronzes.length === 0 && state.prelimBronze && state.prelimBronze[cat]) {
        bronzes = [state.prelimBronze[cat]];
    }
    return { champion, runnerUp, bronzes, bronze, fourth, finalMatch, thirdMatch };
}

function migrateFinalQualifiers(saved) {
    if (Array.isArray(saved.finalQualifiers)) {
        // Old flat format — group by category prefix from labels
        const byCategory = {};
        (saved.finalQualifiers || []).forEach(q => {
            const match = q.label ? q.label.match(/^(.+?)\s+/) : null;
            const cat = match ? match[1] : '未分類';
            if (!byCategory[cat]) byCategory[cat] = [];
            byCategory[cat].push(q);
        });
        state.finalQualifiers = byCategory;
        // Migrate bracketMatches: assign array to first category
        if (Array.isArray(saved.bracketMatches)) {
            const cats = Object.keys(byCategory);
            state.bracketMatches = {};
            if (cats.length > 0 && saved.bracketMatches && saved.bracketMatches.length > 0) {
                state.bracketMatches[cats[0]] = saved.bracketMatches;
            }
        } else {
            state.bracketMatches = saved.bracketMatches || {};
        }
    } else {
        state.finalQualifiers = saved.finalQualifiers || {};
        state.bracketMatches = saved.bracketMatches || {};
    }
    // Auto-select first category with data
    const cats = getFinalsCategories();
    state.activeCategory = saved.activeCategory || (cats.length > 0 ? cats[0] : null);
}

// ============================================================
// Undo / Redo
// ============================================================
const undoStack = [];
const redoStack = [];
const MAX_UNDO = 10;

function collectScores() {
    const scores = {};
    for (const cat in state.activeGroups) {
        state.activeGroups[cat].forEach(g => {
            g.matches.forEach(m => {
                const { v1, v2 } = getMatchScores(m.matchId);
                const f1 = getFF(m.matchId, 1);
                const f2 = getFF(m.matchId, 2);
                if ((v1 || v2) || f1 || f2) {
                    scores[m.matchId] = [v1, v2, f1, f2];
                }
            });
        });
    }
    return scores;
}

// Unified state serialization — single source of truth
function serializeState(scores) {
    return {
        setupPool: state.setupPool,
        activeGroups: state.activeGroups,
        finalQualifiers: state.finalQualifiers,
        manualQualify: state.manualQualify || {},
        bracketMatches: state.bracketMatches || {},
        prelimBronze: state.prelimBronze || {},
        prelimResults: state.prelimResults || {},
        activeCategory: state.activeCategory || null,
        eventTitle: state.eventTitle || '',
        scores: scores || collectScores()
    };
}

function takeSnapshot() {
    return JSON.stringify(serializeState());
}

function pushUndo() {
    undoStack.push(takeSnapshot());
    if (undoStack.length > MAX_UNDO) undoStack.shift();
    redoStack.length = 0;
    updateUndoButtons();
}

function restoreSnapshot(snap) {
    const saved = JSON.parse(snap);
    state.setupPool = saved.setupPool || {};
    state.activeGroups = saved.activeGroups || {};
    state.finalQualifiers = saved.finalQualifiers || {};
    state.manualQualify = saved.manualQualify || {};
    state.bracketMatches = saved.bracketMatches || {};
    state.prelimBronze = saved.prelimBronze || {};
    state.prelimResults = saved.prelimResults || {};
    state.activeCategory = saved.activeCategory || null;
    state.eventTitle = saved.eventTitle || '';
    const h1 = document.getElementById('eventTitle');
    if (h1) h1.textContent = state.eventTitle || '羽球賽務系統';

    refreshPoolList();
    if (Object.keys(state.activeGroups).length > 0) {
        rebuildScoringUI(saved.scores || {});
    } else {
        document.getElementById('scoringArea').innerHTML = '<div class="empty-state"><div class="icon">&#127941;</div><p>尚未開始賽事，請先至「名單設定」完成分組</p></div>';
    }
    if (hasFinalQualifiers()) {
        renderFinalsTabBar();
        renderFinalsList();
    }
    if (getCurrentBracketMatches()) renderInteractiveBracket();
    saveState();
}

function undo() {
    if (undoStack.length === 0) return;
    redoStack.push(takeSnapshot());
    restoreSnapshot(undoStack.pop());
    updateUndoButtons();
    showToast('已復原', 'info');
}

function redo() {
    if (redoStack.length === 0) return;
    undoStack.push(takeSnapshot());
    restoreSnapshot(redoStack.pop());
    updateUndoButtons();
    showToast('已重做', 'info');
}

function updateUndoButtons() {
    const uBtn = document.getElementById('undoBtn');
    const rBtn = document.getElementById('redoBtn');
    if (uBtn) uBtn.disabled = undoStack.length === 0;
    if (rBtn) rBtn.disabled = redoStack.length === 0;
}

document.addEventListener('keydown', function(e) {
    if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) { e.preventDefault(); undo(); }
    if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) { e.preventDefault(); redo(); }

    // Enter / Shift+Enter: jump between score inputs
    if (e.key === 'Enter' && (e.target.classList.contains('score-input') || e.target.classList.contains('bracket-score'))) {
        e.preventDefault();
        const cls = e.target.classList.contains('score-input') ? '.score-input:not([disabled])' : '.bracket-score:not([disabled])';
        const allInputs = Array.from(document.querySelectorAll(cls));
        const idx = allInputs.indexOf(e.target);
        const next = e.shiftKey ? idx - 1 : idx + 1;
        if (next >= 0 && next < allInputs.length) {
            allInputs[next].focus();
            allInputs[next].select();
        }
    }
});

// Keyboard activation for ff-badge (Enter/Space triggers click)
document.addEventListener('keydown', function(e) {
    if ((e.key === 'Enter' || e.key === ' ') && e.target.classList.contains('ff-badge')) {
        e.preventDefault();
        e.target.click();
    }
});

// Auto-select on focus for quick overwrite
document.addEventListener('focusin', function(e) {
    if (e.target.classList.contains('score-input') || e.target.classList.contains('bracket-score')) {
        setTimeout(() => e.target.select(), 0);
    }
});

// ============================================================
// Persistence (localStorage)
// ============================================================
let _quotaWarned = false;
function saveState() {
    try {
        const data = JSON.stringify(serializeState());
        // Quota pre-check: warn when approaching localStorage limit (~5MB)
        if (!_quotaWarned) {
            let used = 0;
            try { for (const k in localStorage) if (localStorage.hasOwnProperty(k)) used += localStorage[k].length; } catch(_) {}
            if (used > 4 * 1024 * 1024) {
                showToast('儲存空間即將不足（已使用 ' + (used / 1024 / 1024).toFixed(1) + 'MB），建議刪除舊賽事或匯出 Excel 備份', 'warning');
                _quotaWarned = true;
                setTimeout(() => { _quotaWarned = false; }, 60000); // Re-check after 1 min
            }
        }
        localStorage.setItem('badminton_state', data);
        // Also save to event-specific key
        if (state.eventId) localStorage.setItem('badminton_event_' + state.eventId, data);
        // Show save indicator
        const ind = document.getElementById('saveIndicator');
        if (ind) {
            ind.textContent = '已自動儲存 ' + new Date().toLocaleTimeString();
            ind.style.color = 'var(--qualified-text)';
            clearTimeout(ind._timer);
            ind._timer = setTimeout(() => { ind.style.color = 'var(--text-hint)'; }, 2000);
        }
        // Update event list timestamp
        if (state.eventId) {
            const list = getEventList();
            const idx = list.findIndex(e => e.id === state.eventId);
            if (idx >= 0) { list[idx].title = state.eventTitle || '未命名賽事'; list[idx].updatedAt = new Date().toISOString(); saveEventList(list); }
        }
    } catch (e) {
        if (e.name === 'QuotaExceededError' || e.code === 22 || e.code === 1014) {
            showToast('儲存空間不足！請刪除不需要的賽事或使用「存檔」匯出 Excel 備份', 'error');
        } else {
            showToast('儲存失敗：' + e.message, 'error');
        }
    }
}

function loadState() {
    const raw = localStorage.getItem('badminton_state');
    if (!raw) return;
    try {
        const saved = JSON.parse(raw);
        state.setupPool = saved.setupPool || {};
        state.activeGroups = saved.activeGroups || {};
        state.manualQualify = saved.manualQualify || {};
        // Migrate flat finalQualifiers/bracketMatches to per-category dict
        migrateFinalQualifiers(saved);
        state.prelimBronze = saved.prelimBronze || {};
        state.prelimResults = saved.prelimResults || {};
        // Set eventId from event list if not set
        if (!state.eventId) {
            const list = getEventList();
            if (list.length > 0) {
                list.sort((a, b) => (b.updatedAt || '').localeCompare(a.updatedAt || ''));
                state.eventId = list[0].id;
            }
        }
        state.eventTitle = saved.eventTitle || '';
        const h1 = document.getElementById('eventTitle');
        if (h1) h1.textContent = state.eventTitle || '羽球賽務系統';
        document.title = (state.eventTitle || '羽球賽務系統') + ' ' + APP_VERSION;

        // Rebuild UI
        refreshPoolList();
        if (Object.keys(state.activeGroups).length > 0) {
            rebuildScoringUI(saved.scores || {});
        }
        if (hasFinalQualifiers()) {
            renderFinalsTabBar();
            renderFinalsList();
        }
        if (getCurrentBracketMatches()) {
            renderInteractiveBracket();
        }
    } catch (e) {
        console.warn('Failed to load saved state:', e);
    }
}

function rebuildScoringUI(savedScores) {
    const area = document.getElementById('scoringArea');
    area.innerHTML = '';

    for (const cat in state.activeGroups) {
        const groups = state.activeGroups[cat];
        const totalPlayers = groups.reduce((s, g) => s + g.members.length, 0);

        const catDiv = document.createElement('div');
        catDiv.innerHTML = `<div class="category-header"><h3>${escapeXml(cat)}（共 ${totalPlayers} 人）</h3></div>`;
        area.appendChild(catDiv);

        groups.forEach(group => {
            const aw = getAlignWidths(group.members);
            const groupCard = document.createElement('div');
            groupCard.className = 'group-card';
            groupCard.innerHTML = `<h4>${escapeXml(group.name)} 組（${group.members.length} 人：${group.members.map(n => escapeXml(n)).join('、')}）</h4>`;

            group.matches.forEach(m => {
                const row = document.createElement('div');
                row.className = 'match-row';
                const saved = savedScores[m.matchId] || ['', '', '', ''];
                const s1Val = saved[0] || '';
                const s2Val = saved[1] || '';
                const ff1Val = saved[2] || '';
                const ff2Val = saved[3] || '';
                const ffLabel = { '': '棄', injury: '傷', voluntary: '棄' };
                row.innerHTML = `
                    <span class="match-no">${m.matchNo}</span>
                    <span class="player-name" id="pn1_${m.matchId}">${alignName(group.members[m.p1], aw.sw, aw.nw)}<span class="ff-badge" id="ff1_${m.matchId}" data-ff="${ff1Val}" onclick="cycleForfeit('${m.matchId}',1)" tabindex="0" role="button" title="點擊切換：傷/棄">${ffLabel[ff1Val] || '棄'}</span></span>
                    <input type="number" class="score-input" id="s1_${m.matchId}" min="0" max="99" placeholder="-" value="${s1Val}">
                    <span class="vs-label">VS</span>
                    <input type="number" class="score-input" id="s2_${m.matchId}" min="0" max="99" placeholder="-" value="${s2Val}">
                    <span class="player-name right" id="pn2_${m.matchId}"><span class="ff-badge" id="ff2_${m.matchId}" data-ff="${ff2Val}" onclick="cycleForfeit('${m.matchId}',2)" tabindex="0" role="button" title="點擊切換：傷/棄">${ffLabel[ff2Val] || '棄'}</span>${alignName(group.members[m.p2], aw.sw, aw.nw)}</span>
                `;
                groupCard.appendChild(row);
                if (ff1Val || ff2Val) setTimeout(() => onForfeit(m.matchId, true), 0);
            });

            const standingsDiv = document.createElement('div');
            standingsDiv.id = `standings_${cat}_${group.name}`;
            standingsDiv.style.marginTop = '10px';
            groupCard.appendChild(standingsDiv);

            const btnCalc = document.createElement('button');
            btnCalc.className = 'btn btn-primary';
            btnCalc.style.marginTop = '8px';
            btnCalc.textContent = '計算戰績';
            btnCalc.onclick = () => renderStandings(cat, group.name);
            groupCard.appendChild(btnCalc);

            area.appendChild(groupCard);
        });
    }
    setTimeout(updateProgress, 0);
}

// Get forfeit value from badge
function getFF(matchId, side) {
    const el = document.getElementById('ff' + side + '_' + matchId);
    return el ? (el.getAttribute('data-ff') || '') : '';
}

// Set forfeit value on badge
function setFF(matchId, side, val) {
    const el = document.getElementById('ff' + side + '_' + matchId);
    if (!el) return;
    el.setAttribute('data-ff', val);
    const labels = { [FF_TYPES.NONE]: '棄', [FF_TYPES.INJURY]: '傷', [FF_TYPES.VOLUNTARY]: '棄' };
    el.textContent = labels[val] || '棄';
}

// Click to cycle: '' → injury → voluntary → ''
function cycleForfeit(matchId, side) {
    pushUndo();
    const cur = getFF(matchId, side);
    const next = cur === FF_TYPES.NONE ? FF_TYPES.INJURY : (cur === FF_TYPES.INJURY ? FF_TYPES.VOLUNTARY : FF_TYPES.NONE);
    setFF(matchId, side, next);
    onForfeit(matchId, false);
    updateProgress();
}

function onForfeit(matchId, silent) {
    const ff1El = document.getElementById('ff1_' + matchId);
    const ff2El = document.getElementById('ff2_' + matchId);
    const s1 = document.getElementById('s1_' + matchId);
    const s2 = document.getElementById('s2_' + matchId);
    const pn1 = document.getElementById('pn1_' + matchId);
    const pn2 = document.getElementById('pn2_' + matchId);
    const row = ff1El ? ff1El.closest('.match-row') : null;
    if (!ff1El || !ff2El || !row) return;

    const f1 = ff1El.getAttribute('data-ff') || '';
    const f2 = ff2El.getAttribute('data-ff') || '';
    row.classList.toggle('has-forfeit', !!(f1 || f2));

    // Style player names
    if (pn1) { pn1.classList.remove('forfeited-injury', 'forfeited-voluntary'); if (f1) pn1.classList.add('forfeited-' + f1); }
    if (pn2) { pn2.classList.remove('forfeited-injury', 'forfeited-voluntary'); if (f2) pn2.classList.add('forfeited-' + f2); }

    // Score handling: forfeit → 0 + lock; opponent → 25 + lock; injury = editable
    if (s1) {
        s1.classList.remove('forfeited-voluntary');
        if (f1 === FF_TYPES.VOLUNTARY) { s1.classList.add('forfeited-voluntary'); s1.value = '0'; s1.disabled = true; }
        else if (f2 && !f1) { s1.value = '25'; s1.disabled = true; }
        else { s1.disabled = false; }
    }
    if (s2) {
        s2.classList.remove('forfeited-voluntary');
        if (f2 === FF_TYPES.VOLUNTARY) { s2.classList.add('forfeited-voluntary'); s2.value = '0'; s2.disabled = true; }
        else if (f1 && !f2) { s2.value = '25'; s2.disabled = true; }
        else { s2.disabled = false; }
    }

    // Cascade: voluntary forfeit → auto-forfeit subsequent matches
    if (!silent && (f1 === FF_TYPES.VOLUNTARY || f2 === FF_TYPES.VOLUNTARY)) {
        cascadeVoluntaryForfeit(matchId, f1 === FF_TYPES.VOLUNTARY ? 1 : 0, f2 === FF_TYPES.VOLUNTARY ? 2 : 0);
    }

    if (!silent) saveState();
}

function cascadeVoluntaryForfeit(matchId, side1, side2) {
    for (const cat in state.activeGroups) {
        for (const group of state.activeGroups[cat]) {
            const mi = group.matches.findIndex(m => m.matchId === matchId);
            if (mi === -1) continue;
            const triggerMatch = group.matches[mi];
            const forfeitPlayers = new Set();
            if (side1) forfeitPlayers.add(triggerMatch.p1);
            if (side2) forfeitPlayers.add(triggerMatch.p2);
            if (forfeitPlayers.size === 0) return;

            for (let k = mi + 1; k < group.matches.length; k++) {
                const m = group.matches[k];
                if (forfeitPlayers.has(m.p1) && !getFF(m.matchId, 1)) {
                    setFF(m.matchId, 1, FF_TYPES.VOLUNTARY);
                    onForfeit(m.matchId, true);
                }
                if (forfeitPlayers.has(m.p2) && !getFF(m.matchId, 2)) {
                    setFF(m.matchId, 2, FF_TYPES.VOLUNTARY);
                    onForfeit(m.matchId, true);
                }
            }
            return;
        }
    }
}

// ============================================================
// Progress Panel (throttled)
// ============================================================
let _progressTimer = null;
function updateProgress() {
    if (_progressTimer) return;
    _progressTimer = requestAnimationFrame(_updateProgressNow);
}
function _updateProgressNow() {
    _progressTimer = null;
    const panel = document.getElementById('progressPanel');
    if (!panel) return;
    if (Object.keys(state.activeGroups).length === 0) { panel.style.display = 'none'; return; }
    panel.style.display = '';

    let totalDone = 0, totalMatches = 0;
    const details = [];
    for (const cat in state.activeGroups) {
        state.activeGroups[cat].forEach(g => {
            let gDone = 0, gTotal = g.matches.length;
            g.matches.forEach(m => {
                const { v1, v2 } = getMatchScores(m.matchId);
                const f1 = getFF(m.matchId, 1);
                const f2 = getFF(m.matchId, 2);
                // A match is complete if both scores filled OR any forfeit
                if ((v1 !== '' && v2 !== '' && !isNaN(v1) && !isNaN(v2)) || f1 || f2) gDone++;
            });
            totalDone += gDone;
            totalMatches += gTotal;
            const isDone = gDone === gTotal;
            details.push(`<span class="progress-group ${isDone ? 'done' : ''}">${cat} ${g.name}：${gDone}/${gTotal}${isDone ? ' ✓' : ''}</span>`);
        });
    }

    const pct = totalMatches > 0 ? Math.round(totalDone / totalMatches * 100) : 0;
    document.getElementById('progressPct').textContent = pct + '%';
    document.getElementById('progressDone').textContent = totalDone;
    document.getElementById('progressTotal').textContent = totalMatches;
    document.getElementById('progressBar').style.width = pct + '%';
    document.getElementById('progressBarText').textContent = totalDone + ' / ' + totalMatches + '（' + pct + '%）';
    document.getElementById('progressDetail').className = 'progress-detail';
    document.getElementById('progressDetail').innerHTML = details.join('');
    // M8: Disable promote button when no scores
    const promoteBtn = document.getElementById('promoteBtn');
    if (promoteBtn) promoteBtn.disabled = totalDone === 0;
}

// Auto-save scores on input/change (event delegation)
let _undoDebounce = null;
let _saveDebounce = null;
document.addEventListener('input', function(e) {
    const isScore = e.target.classList.contains('score-input');
    const isBracket = e.target.classList.contains('bracket-score');
    if (isScore || isBracket) {
        // Validate: no negative scores
        if (e.target.value !== '' && parseFloat(e.target.value) < 0) {
            e.target.value = 0;
            showToast('分數不可為負數', 'error');
        }
        if (isScore) {
            if (!_undoDebounce) pushUndo();
            clearTimeout(_undoDebounce);
            _undoDebounce = setTimeout(() => { _undoDebounce = null; }, 1000);
            updateProgress();
        }
        // Debounced save as safety net (3s) — main save happens on change/blur
        clearTimeout(_saveDebounce);
        _saveDebounce = setTimeout(() => { saveState(); }, 3000);
    }
});
document.addEventListener('change', function(e) {
    const isScore = e.target.classList.contains('score-input');
    const isBracket = e.target.classList.contains('bracket-score');
    if (isScore || isBracket) {
        // Validate negative on change too
        if (e.target.value !== '' && parseFloat(e.target.value) < 0) {
            e.target.value = 0;
            showToast('分數不可為負數', 'error');
        }
        // Warn both-zero for prelim + badminton rule check
        if (isScore) {
            const matchId = e.target.id.replace(/^s[12]_/, '');
            const { v1, v2 } = getMatchScores(matchId);
            if (v1 === '0' && v2 === '0') {
                showToast('提醒：雙方分數皆為 0', 'warning');
            } else if (v1 !== '' && v2 !== '') {
                checkBadmintonScore(v1, v2);
            }
        }
        if (isBracket) {
            const matchId = e.target.id.replace(/^bs[12]_/, '');
            const s1El = document.getElementById('bs1_' + matchId);
            const s2El = document.getElementById('bs2_' + matchId);
            if (s1El && s2El && s1El.value !== '' && s2El.value !== '') {
                checkBadmintonScore(s1El.value, s2El.value);
                if (parseInt(s1El.value) === parseInt(s2El.value)) {
                    showToast('決賽分數相同，無法判定勝者', 'warning');
                }
            }
        }
        // Cancel pending debounce and save immediately on blur/change
        clearTimeout(_saveDebounce);
        saveState();
    }
});
// Safety net: save before page unload
window.addEventListener('beforeunload', function() {
    if (Object.keys(state.activeGroups).length > 0) saveState();
});

// ============================================================
// Tab switching
// ============================================================
const TAB_ORDER = ['setup', 'scoring', 'finals'];
function switchTab(tab) {
    document.querySelectorAll('.tab-btn').forEach(b => {
        const isActive = b.getAttribute('aria-controls') === 'tab-' + tab;
        b.classList.toggle('active', isActive);
        b.setAttribute('aria-selected', isActive);
        b.setAttribute('tabindex', isActive ? '0' : '-1');
    });
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    document.getElementById('tab-' + tab).classList.add('active');
}
// Tab keyboard navigation (Left/Right arrow keys)
document.querySelector('.tabs').addEventListener('keydown', function(e) {
    if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
        const active = document.querySelector('.tab-btn.active');
        const idx = TAB_ORDER.indexOf(active.getAttribute('aria-controls').replace('tab-', ''));
        const next = e.key === 'ArrowRight' ? (idx + 1) % 3 : (idx + 2) % 3;
        switchTab(TAB_ORDER[next]);
        document.querySelectorAll('.tab-btn')[next].focus();
    }
});

// ============================================================
// Player Search
// ============================================================
(function() {
    let _searchTimer = null;
    const searchInput = document.getElementById('playerSearch');
    if (!searchInput) return;
    searchInput.addEventListener('input', function() {
        clearTimeout(_searchTimer);
        _searchTimer = setTimeout(doPlayerSearch, 300);
    });
    searchInput.addEventListener('keydown', function(e) {
        if (e.key === 'Escape') { searchInput.value = ''; clearSearchHighlight(); }
    });
})();

function clearSearchHighlight() {
    document.querySelectorAll('.search-highlight').forEach(el => el.classList.remove('search-highlight'));
}

function doPlayerSearch() {
    clearSearchHighlight();
    const q = (document.getElementById('playerSearch').value || '').trim().toLowerCase();
    if (!q) return;
    const matches = [];
    document.querySelectorAll('.player-name').forEach(el => {
        let text = '';
        el.childNodes.forEach(node => {
            if (node.nodeType === Node.TEXT_NODE) text += node.textContent;
            else if (node.nodeType === Node.ELEMENT_NODE && !node.classList.contains('ff-badge')) text += node.textContent;
        });
        if (text.toLowerCase().includes(q)) {
            matches.push(el);
        }
    });
    if (matches.length === 0) {
        showToast('找不到「' + escapeXml(q) + '」', 'warning');
        return;
    }
    matches.forEach(el => el.classList.add('search-highlight'));
    matches[0].scrollIntoView({ behavior: 'smooth', block: 'center' });
    showToast('找到 ' + matches.length + ' 筆結果', 'success');
}

// ============================================================
// Toast
// ============================================================
let _toastTimer = null;
function showToast(msg, type = 'info') {
    const t = document.getElementById('toast');
    t.textContent = msg;
    t.className = 'toast show ' + type;
    clearTimeout(_toastTimer);
    const duration = (type === 'error' || type === 'warning') ? 4000 : 2500;
    _toastTimer = setTimeout(() => t.className = 'toast', duration);
}

// ============================================================
// Tab 1: Setup
// ============================================================
function addToPool() {
    const cat = document.getElementById('catName').value.trim();
    const text = document.getElementById('playerList').value.trim();
    if (!cat || !text) { showToast('請填寫類別名稱和名單', 'error'); return; }
    const players = text.split('\n').map(l => l.trim()).filter(l => l);
    if (players.length < 2) { showToast('至少需要 2 位選手', 'error'); return; }
    const type = document.querySelector('input[name="matchType"]:checked').value;

    if (state.editingKey && state.editingKey !== cat) {
        delete state.setupPool[state.editingKey];
    }
    state.setupPool[cat] = { type, players };
    state.editingKey = null;
    document.getElementById('catName').value = '';
    document.getElementById('playerList').value = '';
    refreshPoolList();
    saveState();
    showToast(`已儲存「${cat}」`, 'success');
}

function refreshPoolList() {
    const list = document.getElementById('poolList');
    const actions = document.getElementById('poolActions');
    const keys = Object.keys(state.setupPool);

    // Clear all items except poolEmpty
    Array.from(list.querySelectorAll('.pool-item')).forEach(el => el.remove());

    // Ensure poolEmpty element exists
    let empty = document.getElementById('poolEmpty');
    if (!empty) {
        empty = document.createElement('li');
        empty.id = 'poolEmpty';
        empty.className = 'empty-state';
        empty.innerHTML = '<div class="icon">&#127992;</div><p>尚無任何名單，請先新增</p>';
        list.appendChild(empty);
    }

    if (keys.length === 0) {
        empty.style.display = '';
        actions.style.display = 'none';
        return;
    }
    empty.style.display = 'none';
    keys.forEach(cat => {
        const data = state.setupPool[cat];
        const li = document.createElement('li');
        li.className = 'pool-item' + (state.selectedPoolItem === cat ? ' selected' : '');
        li.innerHTML = `<span class="info">${escapeXml(cat)}</span><span class="count">${escapeXml(data.type)} / ${data.players.length} 人</span>`;
        li.onclick = () => { state.selectedPoolItem = cat; refreshPoolList(); };
        list.appendChild(li);
    });
    actions.style.display = 'flex';
    // M2: Disable load/delete when nothing selected
    const loadBtn = actions.querySelector('.btn-light');
    const delBtn = actions.querySelector('.btn-danger');
    if (loadBtn) loadBtn.disabled = !state.selectedPoolItem;
    if (delBtn) delBtn.disabled = !state.selectedPoolItem;
}

function loadPoolItem() {
    if (!state.selectedPoolItem || !state.setupPool[state.selectedPoolItem]) { showToast('請先選取項目', 'error'); return; }
    const cat = state.selectedPoolItem;
    const data = state.setupPool[cat];
    state.editingKey = cat;
    document.getElementById('catName').value = cat;
    document.getElementById('playerList').value = data.players.join('\n');
    document.querySelector(`input[name="matchType"][value="${data.type}"]`).checked = true;
    showToast(`正在編輯「${cat}」`, 'info');
}

async function deletePoolItem() {
    if (!state.selectedPoolItem) return;
    if (!await customConfirm('確定要刪除此名單？')) return;
    delete state.setupPool[state.selectedPoolItem];
    state.selectedPoolItem = null;
    refreshPoolList();
    saveState();
    showToast('已刪除', 'success');
}

async function clearAllPool() {
    if (!await customConfirm('確定要清空所有名單？')) return;
    state.setupPool = {};
    state.selectedPoolItem = null;
    state.editingKey = null;
    refreshPoolList();
    saveState();
    showToast('已清空所有名單', 'success');
}

// Excel import
async function importExcel(event) {
    const file = event.target.files[0];
    if (!file) return;
    try { await loadLib('xlsx'); } catch(err) { showToast(err.message, 'error'); return; }
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const wb = XLSX.read(e.target.result, { type: 'array' });
            wb.SheetNames.forEach(sheet => {
                const data = XLSX.utils.sheet_to_json(wb.Sheets[sheet], { header: 1 });
                const players = [];
                const headerKeywords = ['學校', '姓名', '選手', '名字', '名單', 'name', 'school'];
                data.forEach((row, ri) => {
                    const cells = row.filter(c => c != null && String(c).trim() !== '');
                    if (cells.length === 0) return;
                    const line = cells.join(' ');
                    // Skip header row
                    if (ri === 0 && headerKeywords.some(k => line.includes(k))) return;
                    players.push(line);
                });
                if (players.length === 0) return;
                const mType = sheet.includes('雙') ? '雙打' : '單打';
                state.setupPool[sheet] = { type: mType, players };
            });
            refreshPoolList();
            saveState();
            showToast('Excel 匯入成功', 'success');
        } catch (err) {
            showToast('匯入失敗: ' + err.message, 'error');
        }
    };
    reader.readAsArrayBuffer(file);
    event.target.value = '';
}

// ============================================================
// Tab 2: Smart grouping + scoring
// ============================================================
async function startTournament() {
    const keys = Object.keys(state.setupPool);
    if (keys.length === 0) { showToast('暫存池為空', 'error'); return; }
    if (Object.keys(state.activeGroups).length > 0) {
        if (!await customConfirm('重新分組會覆蓋目前的預賽資料，確定繼續？')) return;
    }
    pushUndo();

    state.activeGroups = {};
    const report = [];
    const area = document.getElementById('scoringArea');
    area.innerHTML = '';

    keys.forEach(cat => {
        const data = state.setupPool[cat];
        // Deduplicate players
        const players = [...new Set(data.players.map(p => p.trim()))].filter(p => p);
        shuffle(players);
        const n = players.length;
        const groups = [];

        if (n < 3) {
            report.push(`【${cat}】共 ${n} 人 → 單組`);
            groups.push(players);
        } else if (n === 3) {
            report.push(`【${cat}】共 3 人 → 3人組: 1`);
            groups.push(players);
        } else if (n === 4) {
            report.push(`【${cat}】共 4 人 → 4人組: 1`);
            groups.push(players);
        } else if (n === 5) {
            report.push(`【${cat}】共 5 人 → 3人組 + 2人組`);
            groups.push(players.slice(0, 3));
            groups.push(players.slice(3));
        } else {
            // n >= 6: 3人組為主，餘數用4人組補
            const remainder = n % 3;
            let g4 = 0;
            if (remainder === 1) g4 = 1;       // e.g. 7 = 3×1 + 4×1
            else if (remainder === 2) g4 = 2;   // e.g. 8 = 4×2
            const g3 = (n - 4 * g4) / 3;
            const parts = [];
            if (g3) parts.push(`3人組: ${g3}`);
            if (g4) parts.push(`4人組: ${g4}`);
            report.push(`【${cat}】共 ${n} 人 → ${parts.join(', ')}`);
            let idx = 0;
            for (let i = 0; i < g3; i++) { groups.push(players.slice(idx, idx + 3)); idx += 3; }
            for (let i = 0; i < g4; i++) { groups.push(players.slice(idx, idx + 4)); idx += 4; }
        }

        // Build UI
        const catDiv = document.createElement('div');
        catDiv.innerHTML = `<div class="category-header"><h3>${escapeXml(cat)}（共 ${n} 人）</h3></div>`;
        area.appendChild(catDiv);

        let matchCounter = 1;
        const catGroups = [];

        groups.forEach((members, gi) => {
            const gName = String.fromCharCode(65 + gi);
            const pairings = getPairings(members.length);
            const aw = getAlignWidths(members);
            const groupCard = document.createElement('div');
            groupCard.className = 'group-card';
            groupCard.innerHTML = `<h4>${escapeXml(gName)} 組（${members.length} 人：${members.map(n => escapeXml(n)).join('、')}）</h4>`;

            const matches = [];
            pairings.forEach(([i, j]) => {
                const matchNo = matchCounter++;
                const matchId = `${cat}_${gName}_${matchNo}`;
                const row = document.createElement('div');
                row.className = 'match-row';
                row.innerHTML = `
                    <span class="match-no">${matchNo}</span>
                    <span class="player-name" id="pn1_${matchId}">${alignName(members[i], aw.sw, aw.nw)}<span class="ff-badge" id="ff1_${matchId}" data-ff="" onclick="cycleForfeit('${matchId}',1)" tabindex="0" role="button" title="點擊切換：傷/棄">棄</span></span>
                    <input type="number" class="score-input" id="s1_${matchId}" min="0" max="99" placeholder="-">
                    <span class="vs-label">VS</span>
                    <input type="number" class="score-input" id="s2_${matchId}" min="0" max="99" placeholder="-">
                    <span class="player-name right" id="pn2_${matchId}"><span class="ff-badge" id="ff2_${matchId}" data-ff="" onclick="cycleForfeit('${matchId}',2)" tabindex="0" role="button" title="點擊切換：傷/棄">棄</span>${alignName(members[j], aw.sw, aw.nw)}</span>
                `;
                groupCard.appendChild(row);
                matches.push({ p1: i, p2: j, matchNo, matchId });
            });

            // Standings button
            const standingsDiv = document.createElement('div');
            standingsDiv.id = `standings_${cat}_${gName}`;
            standingsDiv.style.marginTop = '10px';
            groupCard.appendChild(standingsDiv);

            const btnCalc = document.createElement('button');
            btnCalc.className = 'btn btn-primary';
            btnCalc.style.marginTop = '8px';
            btnCalc.textContent = '計算戰績';
            btnCalc.onclick = () => renderStandings(cat, gName);
            groupCard.appendChild(btnCalc);

            area.appendChild(groupCard);
            catGroups.push({ name: gName, members, matches });
        });

        state.activeGroups[cat] = catGroups;
    });

    switchTab('scoring');
    saveState();
    updateProgress();
    if (report.length) showToast(report.join(' | '), 'info');
}

function getPairings(n) {
    if (n === 2) return [[0, 1]];
    if (n === 3) return [[0, 1], [0, 2], [1, 2]];
    if (n === 4) return [[0, 1], [2, 3], [0, 2], [1, 3], [0, 3], [1, 2]];
    const pairs = [];
    for (let i = 0; i < n; i++) for (let j = i + 1; j < n; j++) pairs.push([i, j]);
    return pairs;
}

function getScores(cat, group) {
    const scores = {};
    group.members.forEach((_, i) => scores[i] = { wins: 0, losses: 0, pf: 0, pa: 0, forfeits: 0 });
    let hasScore = false;
    group.matches.forEach(m => {
        const f1 = getFF(m.matchId, 1);
        const f2 = getFF(m.matchId, 2);

        if (f1 || f2) {
            hasScore = true;

            // Injury forfeit: scores still count, but injured player loses
            if (f1 === FF_TYPES.INJURY && !f2) {
                const { n1, n2 } = getMatchScores(m.matchId);
                if (!isNaN(n1) && !isNaN(n2)) {
                    scores[m.p1].pf += n1; scores[m.p1].pa += n2;
                    scores[m.p2].pf += n2; scores[m.p2].pa += n1;
                }
                scores[m.p1].losses++; scores[m.p1].forfeits++;
                scores[m.p2].wins++;
                return;
            }
            if (f2 === FF_TYPES.INJURY && !f1) {
                const { n1, n2 } = getMatchScores(m.matchId);
                if (!isNaN(n1) && !isNaN(n2)) {
                    scores[m.p1].pf += n1; scores[m.p1].pa += n2;
                    scores[m.p2].pf += n2; scores[m.p2].pa += n1;
                }
                scores[m.p2].losses++; scores[m.p2].forfeits++;
                scores[m.p1].wins++;
                return;
            }

            // Voluntary forfeit or both forfeit: 0 points, auto-loss
            if (f1) { scores[m.p1].losses++; scores[m.p1].forfeits++; }
            if (f2) { scores[m.p2].losses++; scores[m.p2].forfeits++; }
            if (f1 && !f2) scores[m.p2].wins++;
            if (f2 && !f1) scores[m.p1].wins++;
            return;
        }

        // Normal score
        const { n1, n2 } = getMatchScores(m.matchId);
        if (isNaN(n1) || isNaN(n2)) return;
        hasScore = true;
        scores[m.p1].pf += n1; scores[m.p1].pa += n2;
        scores[m.p2].pf += n2; scores[m.p2].pa += n1;
        if (n1 > n2) { scores[m.p1].wins++; scores[m.p2].losses++; }
        else if (n2 > n1) { scores[m.p2].wins++; scores[m.p1].losses++; }
    });
    return { scores, hasScore };
}

function sameRecord(a, b) {
    return a.wins === b.wins && a.losses === b.losses && (a.pf - a.pa) === (b.pf - b.pa);
}

function rankPlayers(scores) {
    return Object.entries(scores).sort((a, b) => {
        if (b[1].wins !== a[1].wins) return b[1].wins - a[1].wins;
        return (b[1].pf - b[1].pa) - (a[1].pf - a[1].pa);
    });
}

function renderStandings(cat, gName) {
    const groups = state.activeGroups[cat];
    const group = groups.find(g => g.name === gName);
    if (!group) return;
    const { scores, hasScore } = getScores(cat, group);
    if (!hasScore) { showToast('請先輸入比分', 'error'); return; }

    const { voluntary: voluntaryPlayers, injury: injuryPlayers } = collectForfeitPlayers(group);

    const ranked = rankPlayers(scores);

    const totalInCat = groups.reduce((s, g) => s + g.members.length, 0);
    const nQualify = getQualifyCount(group.members.length, totalInCat);

    const { hasTie, tiedIndices } = detectTiedGroup(ranked, nQualify);

    const groupKey = `${cat}_${gName}`;
    if (!state.manualQualify) state.manualQualify = {};
    delete state.manualQualify[groupKey];

    const div = document.getElementById(`standings_${cat}_${gName}`);
    const aw = getAlignWidths(group.members);
    let html = '';

    if (hasTie) {
        const minTied = Math.min(...tiedIndices);
        const slotsForTied = nQualify - minTied;
        html += `<div class="tie-warn">⚠ 平手！勝負場數相同，請從平手選手中勾選 ${slotsForTied} 人晉級</div>`;
    }

    html += `<table class="standings-table"><thead><tr>`;
    if (hasTie) html += `<th>晉級</th>`;
    html += `<th>排名</th><th>選手</th><th>勝</th><th>負</th><th>棄權</th><th>得分</th><th>失分</th><th>淨分</th><th>備註</th></tr></thead><tbody>`;

    ranked.forEach(([idx, s], rank) => {
        const isTied = tiedIndices.has(rank);
        const autoQualified = !hasTie && rank < nQualify;
        const isVoluntary = voluntaryPlayers.has(parseInt(idx));
        const isInjury = injuryPlayers.has(parseInt(idx));
        let note = isVoluntary ? '<span style="color:#ea4335;font-weight:600;">棄（不晉級）</span>' : (isInjury ? '<span style="color:#e67e00;font-weight:600;">傷</span>' : '');
        if (isTied && !isVoluntary) note += (note ? ' ' : '') + '<span style="color:#e67e00;font-weight:600;">平手</span>';

        let rowClass = '';
        if (isVoluntary) rowClass = '';
        else if (autoQualified) rowClass = 'qualified';
        else if (isTied) rowClass = 'tied';

        html += `<tr class="${rowClass}"${isVoluntary ? ' style="opacity:0.5;"' : ''}>`;
        if (hasTie) {
            if (isTied && !isVoluntary) {
                const prev = state.manualQualify[groupKey] || [];
                const checked = prev.includes(parseInt(idx)) ? ' checked' : '';
                html += `<td><input type="checkbox" class="tie-check" data-group="${groupKey}" data-idx="${idx}"${checked} onchange="onTieCheck('${groupKey}',${nQualify})"></td>`;
            } else if (rank < [...tiedIndices][0] && !isVoluntary) {
                html += `<td>&#10004;</td>`;
            } else {
                html += `<td></td>`;
            }
        }
        html += `<td>${rank + 1}${autoQualified && !isVoluntary ? ' &#10004;' : ''}</td><td>${alignName(group.members[idx], aw.sw, aw.nw)}</td><td>${s.wins}</td><td>${s.losses}</td><td>${s.forfeits || 0}</td><td>${s.pf}</td><td>${s.pa}</td><td>${s.pf - s.pa}</td><td>${note}</td></tr>`;
    });
    html += '</tbody></table>';
    html += `<button class="btn btn-light" style="margin-top:6px;font-size:12px;" onclick="printGroupStandings('${escapeJsInAttr(cat)}','${escapeJsInAttr(gName)}')">列印本組</button>`;
    div.innerHTML = html;
}

function printGroupStandings(cat, gName) {
    const groups = state.activeGroups[cat];
    const group = groups ? groups.find(g => g.name === gName) : null;
    if (!group) { showToast('找不到該組資料', 'error'); return; }
    const { scores, hasScore } = getScores(cat, group);
    if (!hasScore) { showToast('請先輸入比分', 'error'); return; }

    const { voluntary: voluntaryPlayers, injury: injuryPlayers } = collectForfeitPlayers(group);
    const ranked = rankPlayers(scores);
    const totalInCat = groups.reduce((s, g) => s + g.members.length, 0);
    const nQ = getQualifyCount(group.members.length, totalInCat);

    const eventTitle = getEventTitle();
    const today = new Date();
    const dateStr = `${today.getFullYear()} 年 ${today.getMonth() + 1} 月 ${today.getDate()} 日`;
    const pdfTitle = eventTitle + ' ' + cat + ' ' + gName + '組 成績表';

    const win = openPrintWindow();
    if (!win) return;
    const doc = win.document;
    doc.open();
    doc.write('<!DOCTYPE html><html><head><meta charset="UTF-8">');
    doc.write('<title>' + escapeXml(pdfTitle) + '</title>');
    doc.write('<scr' + 'ipt src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></scr' + 'ipt>');
    doc.write('<scr' + 'ipt src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></scr' + 'ipt>');
    doc.write('<style>');
    doc.write('@media print { body { margin: 0; } .no-print { display: none !important; } @page { margin: 12mm; size: portrait; } }');
    doc.write('* { margin: 0; padding: 0; box-sizing: border-box; }');
    doc.write('body { font-family: "Microsoft JhengHei", "Noto Sans TC", sans-serif; background: #fff; color: #222; }');
    doc.write('.no-print { text-align: center; padding: 12px; background: #f5f5f5; border-bottom: 1px solid #ddd; }');
    doc.write('.no-print button { padding: 8px 16px; font-size: 14px; border-radius: 6px; cursor: pointer; margin: 0 4px; font-weight: 600; border: none; }');
    doc.write('.btn-print { background: #1a73e8; color: #fff; } .btn-pdf { background: #ea4335; color: #fff; }');
    doc.write('.report { max-width: 700px; margin: 0 auto; padding: 30px 40px; }');
    doc.write('.rpt-header { text-align: center; padding-bottom: 20px; margin-bottom: 24px; border-bottom: 3px double #333; }');
    doc.write('.rpt-event { font-size: 24px; font-weight: 900; letter-spacing: 3px; margin-bottom: 4px; }');
    doc.write('.rpt-subtitle { font-size: 18px; font-weight: 700; color: #444; margin-bottom: 6px; }');
    doc.write('.rpt-date { font-size: 13px; color: #666; }');
    doc.write('table { width: 100%; border-collapse: collapse; margin-top: 16px; }');
    doc.write('th { background: #f5f5f5; padding: 8px 10px; text-align: left; font-weight: 700; border-bottom: 2px solid #ddd; font-size: 13px; }');
    doc.write('td { padding: 7px 10px; border-bottom: 1px solid #eee; font-size: 13px; }');
    doc.write('tr.qualified { background: #e6f4ea; } tr.qualified td:first-child { font-weight: 700; color: #137333; }');
    doc.write('tr { page-break-inside: avoid; }');
    doc.write('.note-forfeit { color: #ea4335; font-weight: 600; } .note-injury { color: #e67e00; font-weight: 600; }');
    doc.write('.rpt-footer { margin-top: 28px; padding-top: 16px; border-top: 3px double #333; text-align: center; font-size: 13px; color: #888; }');
    doc.write('</style>');
    doc.write('</head><body>');

    doc.write('<div class="no-print"><button class="btn-print" onclick="window.print()">列印</button><button class="btn-pdf" onclick="downloadPDF()">下載 PDF</button></div>');
    doc.write('<div class="report" id="reportContent">');
    doc.write('<div class="rpt-header">');
    doc.write('<div class="rpt-event">' + escapeXml(eventTitle) + '</div>');
    doc.write('<div class="rpt-subtitle">' + escapeXml(cat) + ' ' + escapeXml(gName) + '組 成績表</div>');
    doc.write('<div class="rpt-date">' + dateStr + '</div>');
    doc.write('</div>');

    doc.write('<table><thead><tr><th>排名</th><th>選手</th><th>勝</th><th>負</th><th>棄權</th><th>得分</th><th>失分</th><th>淨分</th><th>備註</th></tr></thead><tbody>');
    ranked.forEach(([idx, s], rank) => {
        const isQ = rank < nQ;
        const isV = voluntaryPlayers.has(parseInt(idx));
        const isI = injuryPlayers.has(parseInt(idx));
        let note = isV ? '<span class="note-forfeit">棄（不晉級）</span>' : (isI ? '<span class="note-injury">傷</span>' : '');
        if (isQ && !isV) note += (note ? ' ' : '') + '晉級';
        doc.write('<tr' + (isQ && !isV ? ' class="qualified"' : '') + (isV ? ' style="opacity:0.5;"' : '') + '>');
        doc.write('<td>' + (rank + 1) + '</td>');
        doc.write('<td>' + escapeXml(group.members[parseInt(idx)]) + '</td>');
        doc.write('<td>' + s.wins + '</td><td>' + s.losses + '</td><td>' + (s.forfeits || 0) + '</td>');
        doc.write('<td>' + s.pf + '</td><td>' + s.pa + '</td><td>' + (s.pf - s.pa) + '</td>');
        doc.write('<td>' + note + '</td></tr>');
    });
    doc.write('</tbody></table>');

    doc.write('<div class="rpt-footer">' + escapeXml(eventTitle) + ' 大會製</div>');
    doc.write('</div>');

    _writeReportPDFScript(doc, pdfTitle);
    doc.write('</body></html>');
    doc.close();
}

function onTieCheck(groupKey, nQualify) {
    pushUndo();
    if (!state.manualQualify) state.manualQualify = {};
    const checks = document.querySelectorAll(`.tie-check[data-group="${groupKey}"]`);
    const selected = [];
    checks.forEach(cb => { if (cb.checked) selected.push(parseInt(cb.dataset.idx)); });

    // Count auto-qualified rows (those with ✔ in first column, above tied group)
    const table = checks[0].closest('table');
    let autoCount = 0;
    table.querySelectorAll('tbody tr').forEach(tr => {
        const firstTd = tr.querySelector('td');
        if (firstTd && firstTd.textContent.trim() === '✔') autoCount++;
    });
    const slotsForTied = nQualify - autoCount;

    if (selected.length > slotsForTied) {
        // Uncheck the one just clicked (last in selected)
        const lastIdx = selected[selected.length - 1];
        checks.forEach(cb => { if (parseInt(cb.dataset.idx) === lastIdx) cb.checked = false; });
        selected.pop();
        showToast(`平手晉級名額僅 ${slotsForTied} 人，已達上限`, 'error');
    }

    state.manualQualify[groupKey] = selected;
    saveState();
}

function getQualifyCount(nMembers, totalInCat) {
    if (totalInCat === 5) return 2;
    if (nMembers >= 6) return Math.ceil(nMembers / 2);
    if (nMembers >= 4) return 2;
    return 1;
}

function getGroupQualifiers(cat, group) {
    const { scores, hasScore } = getScores(cat, group);
    if (!hasScore) return [];
    const { voluntary: voluntaryPlayers } = collectForfeitPlayers(group);
    const ranked = rankPlayers(scores);
    const totalInCat = state.activeGroups[cat].reduce((s, g) => s + g.members.length, 0);
    const nQ = getQualifyCount(group.members.length, totalInCat);

    const { hasTie, tiedIndices } = detectTiedGroup(ranked, nQ);
    if (hasTie) {
        const minTied = Math.min(...tiedIndices);
        const boundaryScore = ranked[nQ - 1][1];
        const groupKey = `${cat}_${group.name}`;
        const manual = (state.manualQualify && state.manualQualify[groupKey]) || [];
        const result = [];
        ranked.forEach(([idx, s], rank) => {
            if (voluntaryPlayers.has(parseInt(idx))) return;
            if (rank < minTied) result.push(group.members[idx]);
            else if (sameRecord(s, boundaryScore) && manual.includes(parseInt(idx))) result.push(group.members[idx]);
        });
        return result;
    }

    return ranked.slice(0, nQ).filter(([idx]) => !voluntaryPlayers.has(parseInt(idx))).map(([idx]) => group.members[idx]);
}

async function promoteWinners() {
    // Warn if existing bracket data will be overwritten
    if (state.bracketMatches && Object.keys(state.bracketMatches).length > 0) {
        if (!await customConfirm('重新結算將清除所有決賽對戰資料，確定要繼續嗎？')) return;
    }
    pushUndo();
    // Check for unresolved ties
    if (!state.manualQualify) state.manualQualify = {};
    for (const cat in state.activeGroups) {
        for (const g of state.activeGroups[cat]) {
            const { scores, hasScore } = getScores(cat, g);
            if (!hasScore) continue;
            const ranked = rankPlayers(scores);
            const totalInCat = state.activeGroups[cat].reduce((s, gr) => s + gr.members.length, 0);
            const nQ = getQualifyCount(g.members.length, totalInCat);
            const { hasTie, tiedIndices } = detectTiedGroup(ranked, nQ);
            if (hasTie) {
                const minTied = Math.min(...tiedIndices);
                const groupKey = `${cat}_${g.name}`;
                const manual = state.manualQualify[groupKey] || [];
                const slotsForTied = nQ - minTied;
                if (manual.length !== slotsForTied) {
                    showToast(`${cat} ${g.name} 組有平手，請先在戰績表中勾選晉級者（需選 ${slotsForTied} 人）`, 'error');
                    return;
                }
            }
        }
    }

    const allWinners = {};
    const prelimBronze = {};
    let totalCount = 0;
    for (const cat in state.activeGroups) {
        const groups = state.activeGroups[cat];
        if (!allWinners[cat]) allWinners[cat] = [];
        groups.forEach(g => {
            const qs = getGroupQualifiers(cat, g);
            if (qs.length === 0) return;
            // Label includes group name when category has multiple groups
            const groupWinners = qs.map((name, i) => ({
                label: groups.length === 1 ? `第${i + 1}名` : `${g.name}組第${i + 1}名`,
                name
            }));
            allWinners[cat].push(...groupWinners);
            totalCount += groupWinners.length;

            // 3-person group: store 3rd place as prelim bronze
            if (g.members.length === 3 && qs.length === 2) {
                const third = g.members.find(name => !qs.includes(name));
                if (third) prelimBronze[cat] = third;
            }
        });
        if (allWinners[cat].length === 0) delete allWinners[cat];
    }
    if (totalCount === 0) { showToast('無晉級者，請先輸入比分', 'error'); return; }
    state.finalQualifiers = allWinners;
    state.bracketMatches = {};
    state.prelimBronze = prelimBronze;
    state.prelimResults = {};

    // For single-group categories (all results determined in prelim), store full rankings
    for (const cat in state.activeGroups) {
        const groups = state.activeGroups[cat];
        if (groups.length !== 1) continue;
        const g = groups[0];
        if (allWinners[cat] && allWinners[cat].length >= 2) continue; // has bracket, skip
        const { scores, hasScore } = getScores(cat, g);
        if (!hasScore) continue;
        const { voluntary: voluntaryPlayers } = collectForfeitPlayers(g);
        const ranked = rankPlayers(scores).filter(([idx]) => !voluntaryPlayers.has(parseInt(idx)));
        if (ranked.length < 2) continue;
        const champion = g.members[parseInt(ranked[0][0])];
        const runnerUp = g.members[parseInt(ranked[1][0])];
        const bronzes = ranked.length >= 3 ? [g.members[parseInt(ranked[2][0])]] : [];
        const fourth = ranked.length >= 4 ? g.members[parseInt(ranked[3][0])] : null;
        // Collect prelim match data for detail table
        const prelimMatchData = g.matches.map(m => {
            const { n1, n2 } = getMatchScores(m.matchId);
            const f1 = getFF(m.matchId, 1);
            const f2 = getFF(m.matchId, 2);
            const p1Name = g.members[m.p1];
            const p2Name = g.members[m.p2];
            let winner = null;
            if (f1 && !f2) winner = p2Name;
            else if (f2 && !f1) winner = p1Name;
            else if (!isNaN(n1) && !isNaN(n2) && n1 !== n2) winner = n1 > n2 ? p1Name : p2Name;
            return { p1: p1Name, p2: p2Name, s1: isNaN(n1) ? '' : String(n1), s2: isNaN(n2) ? '' : String(n2), winner, round: 0, matchIdx: 0, isPrelim: true };
        }).filter(m => m.winner);
        state.prelimResults[cat] = { champion, runnerUp, bronzes, fourth, matches: prelimMatchData };
        // Ensure this category appears in finals even with <2 qualifiers
        if (!allWinners[cat]) {
            allWinners[cat] = ranked.map(([idx], i) => ({ label: `第${i + 1}名`, name: g.members[parseInt(idx)] }));
            totalCount += ranked.length;
        }
    }

    // Auto-generate bracket for ALL categories
    // For first-round matches where both players came from the same 2-person prelim group,
    // auto-fill scores from prelim and confirm the winner
    let autoBracketCount = 0;
    let autoCompleteCount = 0;
    for (const fKey in allWinners) {
        if (allWinners[fKey].length < 2) continue; // single qualifier = champion decided in prelim
        const bracketMatches = buildBracketMatches(allWinners[fKey]);

        // Scan first-round real matches for pairs from same 2-person prelim group
        for (const bm of bracketMatches) {
            if (bm.round !== 0) continue;
            if (bm.p1 === '—BYE—' || bm.p2 === '—BYE—') continue;
            if (bm.p1 === '—TBD—' || bm.p2 === '—TBD—') continue;

            let sourceGroup = null;
            for (const cat in state.activeGroups) {
                for (const g of state.activeGroups[cat]) {
                    if (g.members.length === 2 && g.members.includes(bm.p1) && g.members.includes(bm.p2)) {
                        sourceGroup = g;
                        break;
                    }
                }
                if (sourceGroup) break;
            }
            if (sourceGroup && sourceGroup.matches.length === 1) {
                const pm = sourceGroup.matches[0];
                const { n1, n2 } = getMatchScores(pm.matchId);
                const f1 = getFF(pm.matchId, 1);
                const f2 = getFF(pm.matchId, 2);
                const hasScores = (!isNaN(n1) && !isNaN(n2) && n1 !== n2) || f1 || f2;
                if (hasScores) {
                    const prelimP1Name = sourceGroup.members[pm.p1];
                    if (bm.p1 === prelimP1Name) {
                        bm.s1 = String(isNaN(n1) ? 0 : n1);
                        bm.s2 = String(isNaN(n2) ? 0 : n2);
                    } else {
                        bm.s1 = String(isNaN(n2) ? 0 : n2);
                        bm.s2 = String(isNaN(n1) ? 0 : n1);
                    }
                    const bs1 = parseInt(bm.s1), bs2 = parseInt(bm.s2);
                    if (bs1 !== bs2) {
                        bm.winner = bs1 > bs2 ? bm.p1 : bm.p2;
                        const loser = bm.winner === bm.p1 ? bm.p2 : bm.p1;
                        // Advance winner to next round
                        const nextRound = bm.round + 1;
                        const nextMatchIdx = Math.floor(bm.matchIdx / 2);
                        const nextSlot = bm.matchIdx % 2;
                        const nextMatch = bracketMatches.find(x => x.round === nextRound && x.matchIdx === nextMatchIdx && !x.isThirdPlace);
                        if (nextMatch) {
                            if (nextSlot === 0) nextMatch.p1 = bm.winner;
                            else nextMatch.p2 = bm.winner;
                        }
                        // Route semi-final loser to 3rd place match
                        const thirdMatch = bracketMatches.find(x => x.isThirdPlace);
                        if (thirdMatch) {
                            const maxRound = Math.max(...bracketMatches.filter(x => !x.isThirdPlace).map(x => x.round));
                            if (bm.round === maxRound - 1) {
                                if (bm.matchIdx === 0) thirdMatch.p1 = loser;
                                else if (bm.matchIdx === 1) thirdMatch.p2 = loser;
                            }
                        }
                        autoCompleteCount++;
                    }
                }
            }
        }

        // Auto-resolve any BYE matches that became ready after auto-fill
        autoResolveBracketBYEs(bracketMatches);

        state.bracketMatches[fKey] = bracketMatches;
        autoBracketCount++;
    }

    state.activeCategory = Object.keys(allWinners)[0];
    switchTab('finals');
    switchFinalsCategory(state.activeCategory);
    saveState();
    const catCount = Object.keys(allWinners).length;
    let msg = `${totalCount} 位選手晉級決賽（${catCount} 個項目）`;
    if (autoCompleteCount > 0) msg += `，${autoCompleteCount} 組已自動完賽`;
    else if (autoBracketCount > 0) msg += `，${autoBracketCount} 組已自動產生對戰圖`;
    showToast(msg, 'success');
}

// ============================================================
// Tab 3: Finals — Category Tab Bar & Overview
// ============================================================
function renderFinalsTabBar() {
    const bar = document.getElementById('finalsCategoryBar');
    const cats = getFinalsCategories();
    if (cats.length === 0) { bar.style.display = 'none'; return; }
    bar.style.display = 'flex';
    bar.innerHTML = '';
    // 全場總覽 tab
    const ovBtn = document.createElement('button');
    ovBtn.className = 'finals-cat-tab' + (state.activeCategory === null ? ' active' : '');
    ovBtn.textContent = '全場總覽';
    ovBtn.onclick = () => switchFinalsCategory(null);
    bar.appendChild(ovBtn);
    // Per-category tabs
    cats.forEach(cat => {
        const btn = document.createElement('button');
        btn.className = 'finals-cat-tab' + (state.activeCategory === cat ? ' active' : '');
        const result = getBracketResultsForCategory(cat);
        let statusHtml = '';
        if (result) statusHtml = '<span class="cat-status done">已完賽</span>';
        else if (state.bracketMatches[cat] && state.bracketMatches[cat].length > 0) statusHtml = '<span class="cat-status in-progress">進行中</span>';
        btn.innerHTML = escapeXml(cat) + statusHtml;
        btn.onclick = () => switchFinalsCategory(cat);
        bar.appendChild(btn);
    });
}

function switchFinalsCategory(cat) {
    state.activeCategory = cat;
    const overview = document.getElementById('finalsOverview');
    const content = document.getElementById('finalsCategoryContent');
    if (cat === null) {
        overview.style.display = '';
        content.style.display = 'none';
        renderFinalsOverview();
    } else {
        overview.style.display = 'none';
        content.style.display = '';
        const isPrelimOnly = state.prelimResults && state.prelimResults[cat] && (!state.bracketMatches[cat] || state.bracketMatches[cat].length === 0);
        document.getElementById('finalsCatTitle').textContent = cat + (isPrelimOnly ? ' — 預賽成績' : ' — 決賽單淘汰管理區');
        // Toggle action bars: bracket vs prelim
        document.getElementById('finalsActionBar').style.display = isPrelimOnly ? 'none' : '';
        document.getElementById('prelimActionBar').style.display = isPrelimOnly ? '' : 'none';
        if (isPrelimOnly) {
            renderPrelimFinalsList(cat);
            document.getElementById('finalsScoreArea').innerHTML = '';
            document.getElementById('bracketArea').innerHTML = '';
            renderPrelimResultCard(cat);
        } else {
            renderFinalsList();
            document.getElementById('finalsScoreArea').innerHTML = '';
            const bm = getCurrentBracketMatches();
            if (bm && bm.length > 0) renderInteractiveBracket();
            else document.getElementById('bracketArea').innerHTML = '';
        }
    }
    renderFinalsTabBar();
}

function renderFinalsOverview() {
    const area = document.getElementById('finalsOverviewContent');
    const cats = getFinalsCategories();
    if (cats.length === 0) { area.innerHTML = '<p class="empty-state">尚無晉級資料</p>'; return; }
    let html = '<div style="overflow-x:auto;-webkit-overflow-scrolling:touch;"><table class="overview-table"><tr><th>組別</th><th>晉級人數</th><th>賽程狀態</th><th>冠軍</th><th>亞軍</th><th>季軍</th><th></th></tr>';
    cats.forEach(cat => {
        const qualifiers = state.finalQualifiers[cat] || [];
        const result = getBracketResultsForCategory(cat);
        const hasBracket = state.bracketMatches[cat] && state.bracketMatches[cat].length > 0;
        let status, champion = '—', runnerUp = '—', bronze = '—';
        if (result) {
            status = '<span style="color:var(--qualified-text);font-weight:600;">已完賽</span>';
            champion = escapeXml(result.champion);
            runnerUp = escapeXml(result.runnerUp);
            bronze = result.bronzes.length > 0 ? escapeXml(result.bronzes.join('、')) : '—';
        } else if (hasBracket) {
            status = '<span style="color:#e65100;font-weight:600;">進行中</span>';
        } else {
            status = '<span style="color:var(--text-muted);">未開始</span>';
        }
        html += '<tr><td style="font-weight:600;">' + escapeXml(cat) + '</td>';
        html += '<td>' + qualifiers.length + ' 人</td>';
        html += '<td>' + status + '</td>';
        html += '<td>' + champion + '</td><td>' + runnerUp + '</td><td>' + bronze + '</td>';
        html += '<td><button class="btn btn-light" style="padding:4px 12px;font-size:12px;" onclick="switchFinalsCategory(\'' + escapeJsInAttr(cat) + '\')">管理</button></td></tr>';
    });
    html += '</table></div>';
    area.innerHTML = html;
}

// ============================================================
// Tab 3: Finals — Per-Category Functions
// ============================================================
function renderFinalsList() {
    const list = document.getElementById('finalsList');

    // Clear dynamic items only
    Array.from(list.querySelectorAll('.finals-item')).forEach(el => el.remove());

    // Ensure finalsEmpty element exists
    let empty = document.getElementById('finalsEmpty');
    if (!empty) {
        empty = document.createElement('li');
        empty.id = 'finalsEmpty';
        empty.className = 'empty-state';
        empty.innerHTML = '<div class="icon">&#127942;</div><p>尚無晉級者，請先在預賽計分中結算冠軍</p>';
        list.appendChild(empty);
    }

    const qualifiers = getCurrentFinalQualifiers();
    if (qualifiers.length === 0) {
        empty.style.display = '';
        return;
    }
    empty.style.display = 'none';
    const aw = getAlignWidths(qualifiers.map(q => q.name));
    qualifiers.forEach((q, i) => {
        const li = document.createElement('li');
        li.className = 'finals-item';
        li.innerHTML = `<span class="rank">${i + 1}</span><span>${escapeXml(q.label)}：${alignName(q.name, aw.sw, aw.nw)}</span>`;
        list.appendChild(li);
    });
}

function renderPrelimFinalsList(cat) {
    const list = document.getElementById('finalsList');
    Array.from(list.querySelectorAll('.finals-item')).forEach(el => el.remove());
    let empty = document.getElementById('finalsEmpty');
    if (empty) empty.style.display = 'none';

    const result = state.prelimResults[cat];
    if (!result) return;
    const medals = ['🥇', '🥈', '🥉'];
    const labels = ['冠軍', '亞軍', '季軍', '殿軍'];
    const players = [result.champion, result.runnerUp, ...(result.bronzes || [])];
    if (result.fourth) players.push(result.fourth);
    const aw = getAlignWidths(players);
    players.forEach((name, i) => {
        const li = document.createElement('li');
        li.className = 'finals-item';
        const medal = medals[i] || '';
        li.innerHTML = `<span class="rank">${medal || (i + 1)}</span><span>${labels[i] || '第' + (i + 1) + '名'}：${alignName(name, aw.sw, aw.nw)}</span>`;
        list.appendChild(li);
    });
}

async function shuffleFinals() {
    const qualifiers = getCurrentFinalQualifiers();
    if (qualifiers.length === 0) { showToast('尚無晉級者', 'error'); return; }
    if (!await customConfirm('重新抽籤將打亂目前順序，確定繼續？')) return;
    pushUndo();
    shuffle(qualifiers);
    renderFinalsList();
    saveState();
    showToast('已重新抽籤', 'success');
}

// Build bracket matches array from a list of qualifiers (reusable helper)
// Standard bracket seed order: distributes BYEs evenly across all quadrants
// e.g. size=8 → [0,7,3,4,1,6,2,5] (seed 0 vs 7, seed 3 vs 4, etc.)
function bracketSeedOrder(n) {
    if (n === 1) return [0];
    const half = bracketSeedOrder(n / 2);
    return half.reduce((acc, seed) => { acc.push(seed); acc.push(n - 1 - seed); return acc; }, []);
}

function buildBracketMatches(qualifiers) {
    const realPlayers = qualifiers.map(q => q.name);
    const size = Math.pow(2, Math.ceil(Math.log2(realPlayers.length)));
    const rounds = Math.log2(size);

    // Distribute BYEs evenly using standard bracket seeding
    // BYEs (highest "seeds") face top seeds and spread across all bracket halves
    const seedOrder = bracketSeedOrder(size);
    const players = new Array(size);
    for (let pos = 0; pos < size; pos++) {
        const seedRank = seedOrder[pos];
        players[pos] = seedRank < realPlayers.length ? realPlayers[seedRank] : '—BYE—';
    }

    const matches = [];
    let currentRound = [];
    for (let i = 0; i < players.length; i += 2) currentRound.push([players[i], players[i + 1]]);

    for (let r = 0; r < rounds; r++) {
        currentRound.forEach(([p1, p2], mi) => {
            const b1 = p1 === '—BYE—', b2 = p2 === '—BYE—';
            const tbd1 = p1 === '—TBD—', tbd2 = p2 === '—TBD—';
            // Only auto-resolve BYE when opponent is a real player (not TBD)
            let winner = null;
            if (b1 && b2) winner = '—BYE—';
            else if (b2 && !b1 && !tbd1) winner = p1;
            else if (b1 && !b2 && !tbd2) winner = p2;
            matches.push({ id: `fb_r${r}m${mi}`, round: r, matchIdx: mi, p1, p2, s1: '', s2: '', winner });
        });
        const next = [];
        for (let i = 0; i < currentRound.length; i += 2) {
            const w1 = currentRound[i][0] === '—BYE—' ? currentRound[i][1] : (currentRound[i][1] === '—BYE—' ? currentRound[i][0] : null);
            const w2 = (i + 1 < currentRound.length) ? (currentRound[i + 1][0] === '—BYE—' ? currentRound[i + 1][1] : (currentRound[i + 1][1] === '—BYE—' ? currentRound[i + 1][0] : null)) : null;
            next.push([w1 || '—TBD—', w2 || '—TBD—']);
        }
        currentRound = next;
    }

    // Add 3rd place match if there are semi-finals (≥4 real players)
    if (qualifiers.length >= 4 && rounds >= 2) {
        const maxRound = rounds - 1;
        matches.push({ id: 'fb_3rd', round: maxRound, matchIdx: -1, p1: '—TBD—', p2: '—TBD—', s1: '', s2: '', winner: null, isThirdPlace: true });
    }
    return matches;
}

// Auto-resolve BYE matches that have a real player opponent (not TBD)
// Called after confirmBracketWinner to cascade BYE advancements
function autoResolveBracketBYEs(matches) {
    let changed = true;
    while (changed) {
        changed = false;
        for (const m of matches) {
            if (m.winner) continue;
            const b1 = m.p1 === '—BYE—', b2 = m.p2 === '—BYE—';
            if (!b1 && !b2) continue;
            if (m.p1 === '—TBD—' || m.p2 === '—TBD—') continue;
            let autoWinner;
            if (b1 && b2) autoWinner = '—BYE—';
            else if (b2) autoWinner = m.p1;
            else autoWinner = m.p2;
            m.winner = autoWinner;
            changed = true;
            if (!m.isThirdPlace) {
                const nextRound = m.round + 1;
                const nextMatchIdx = Math.floor(m.matchIdx / 2);
                const nextSlot = m.matchIdx % 2;
                const nextMatch = matches.find(x => x.round === nextRound && x.matchIdx === nextMatchIdx && !x.isThirdPlace);
                if (nextMatch) {
                    if (nextSlot === 0) nextMatch.p1 = autoWinner;
                    else nextMatch.p2 = autoWinner;
                }
                // Route semi-final loser to 3rd place (skip BYE losers)
                const thirdMatch = matches.find(x => x.isThirdPlace);
                if (thirdMatch) {
                    const maxRound = Math.max(...matches.filter(x => !x.isThirdPlace).map(x => x.round));
                    if (m.round === maxRound - 1) {
                        const loser = autoWinner === m.p1 ? m.p2 : m.p1;
                        if (loser !== '—BYE—' && loser !== '—TBD—') {
                            if (m.matchIdx === 0) thirdMatch.p1 = loser;
                            else if (m.matchIdx === 1) thirdMatch.p2 = loser;
                        }
                    }
                }
            }
        }
    }
}

async function generateBracket() {
    const qualifiers = getCurrentFinalQualifiers();
    if (qualifiers.length < 2) { showToast('至少需要 2 位選手', 'error'); return; }
    const currentBracket = getCurrentBracketMatches();
    if (currentBracket && currentBracket.length > 0) {
        if (!await customConfirm('重新產生對戰圖會覆蓋目前的決賽資料，確定繼續？')) return;
    }
    pushUndo();

    setCurrentBracketMatches(buildBracketMatches(qualifiers));
    saveState();
    renderInteractiveBracket();
    renderFinalsTabBar();
    showToast('已產生互動式對戰圖', 'success');
}

function renderBracketMatchHtml(m) {
    const b1 = m.p1 === '—BYE—', b2 = m.p2 === '—BYE—';
    const tbd1 = m.p1 === '—TBD—', tbd2 = m.p2 === '—TBD—';
    const hasReal = !b1 && !b2 && !tbd1 && !tbd2;

    const p1Display = b1 ? '<span style="color:var(--text-placeholder)">輪空</span>' : (tbd1 ? '<span style="color:var(--text-placeholder)">待定</span>' : escapeXml(m.p1));
    const p2Display = b2 ? '<span style="color:var(--text-placeholder)">輪空</span>' : (tbd2 ? '<span style="color:var(--text-placeholder)">待定</span>' : escapeXml(m.p2));

    const w1 = m.winner === m.p1 && !b1 && !tbd1;
    const w2 = m.winner === m.p2 && !b2 && !tbd2;

    const p1Short = !b1 && !tbd1 ? escapeXml(m.p1.replace(/.*\s/, '')) : '';
    const p2Short = !b2 && !tbd2 ? escapeXml(m.p2.replace(/.*\s/, '')) : '';
    const scoreInput1 = hasReal ? `<input type="number" class="bracket-score" id="bs1_${m.id}" value="${m.s1}" min="0" placeholder="${p1Short}" title="${escapeXml(m.p1)} 的分數" oninput="onBracketScore('${m.id}')">` : '';
    const scoreInput2 = hasReal ? `<input type="number" class="bracket-score" id="bs2_${m.id}" value="${m.s2}" min="0" placeholder="${p2Short}" title="${escapeXml(m.p2)} 的分數" oninput="onBracketScore('${m.id}')">` : '';

    const confirmDisabled = !hasReal || tbd1 || tbd2 ? ' disabled' : '';
    const confirmLabel = m.winner ? '✓ ' + escapeXml(m.winner) : '確認勝者';

    return `
        <div class="bracket-slot ${w1 ? 'winner' : ''}"><span class="bracket-player-name">${p1Display}</span>${scoreInput1}</div>
        <div class="bracket-slot ${w2 ? 'winner' : ''}"><span class="bracket-player-name">${p2Display}</span>${scoreInput2}</div>
        <button class="bracket-confirm" onclick="confirmBracketWinner('${m.id}')"${confirmDisabled}${m.winner ? ' style="background:var(--qualified-bg);color:var(--qualified-text)"' : ''}>${confirmLabel}</button>
    `;
}

function renderInteractiveBracket() {
    const matches = getCurrentBracketMatches();
    if (!matches || matches.length === 0) return;

    const bracketDiv = document.getElementById('bracketArea');
    bracketDiv.innerHTML = '';

    const card = document.createElement('div');
    card.className = 'card';
    const title = document.getElementById('finalTitle').value.trim() || '決賽對戰表';
    card.innerHTML = `<h3>${escapeXml(title)} — 即時計分</h3>`;

    const bracketContainer = document.createElement('div');
    bracketContainer.className = 'bracket';
    bracketContainer.style.display = 'flex';
    bracketContainer.style.alignItems = 'center';

    // Exclude 3rd place match from normal bracket
    const normalMatches = matches.filter(m => !m.isThirdPlace);
    const thirdMatch = matches.find(m => m.isThirdPlace);

    const rounds = getBracketRoundCount(matches);

    for (let r = 0; r < rounds; r++) {
        const roundDiv = document.createElement('div');
        roundDiv.className = 'bracket-round';
        const roundName = getRoundName(r, rounds);
        roundDiv.innerHTML = `<h4>${roundName}</h4>`;

        const rMatches = normalMatches.filter(m => m.round === r);
        rMatches.forEach(m => {
            const matchDiv = document.createElement('div');
            matchDiv.className = 'bracket-match';
            matchDiv.innerHTML = renderBracketMatchHtml(m);
            roundDiv.appendChild(matchDiv);
        });

        bracketContainer.appendChild(roundDiv);
    }

    card.appendChild(bracketContainer);

    // 3rd place match section
    if (thirdMatch) {
        const thirdSection = document.createElement('div');
        thirdSection.style.cssText = 'margin-top: 16px; padding-top: 16px; border-top: 2px dashed var(--border);';
        thirdSection.innerHTML = '<h4 style="color: #ef6c00; margin-bottom: 10px; font-size: 15px;">🥉 季軍賽</h4>';
        const matchDiv = document.createElement('div');
        matchDiv.className = 'bracket-match';
        matchDiv.style.maxWidth = '280px';
        matchDiv.innerHTML = renderBracketMatchHtml(thirdMatch);
        thirdSection.appendChild(matchDiv);
        card.appendChild(thirdSection);
    }

    // Result card
    const resultDiv = document.createElement('div');
    resultDiv.id = 'bracketResultArea';
    card.appendChild(resultDiv);

    bracketDiv.appendChild(card);
    renderBracketResult();
}

function onBracketScore(matchId) {
    const matches = getCurrentBracketMatches();
    if (!matches) return;
    const m = matches.find(x => x.id === matchId);
    if (!m) return;
    const s1El = document.getElementById('bs1_' + matchId);
    const s2El = document.getElementById('bs2_' + matchId);
    m.s1 = s1El ? s1El.value : '';
    m.s2 = s2El ? s2El.value : '';
    saveState();
}

function confirmBracketWinner(matchId) {
    pushUndo();
    const matches = getCurrentBracketMatches();
    if (!matches) return;
    const m = matches.find(x => x.id === matchId);
    if (!m) return;

    const s1 = parseInt(m.s1), s2 = parseInt(m.s2);
    if (isNaN(s1) || isNaN(s2)) { showToast('請先輸入雙方分數', 'error'); return; }
    if (s1 < 0 || s2 < 0) { showToast('分數不可為負數', 'error'); return; }
    if (s1 === s2) { showToast('分數相同，無法判定勝者', 'error'); return; }
    checkBadmintonScore(s1, s2);

    const winner = s1 > s2 ? m.p1 : m.p2;
    const loser = s1 > s2 ? m.p2 : m.p1;
    m.winner = winner;

    // Skip advancing for 3rd place match
    if (!m.isThirdPlace) {
        // Advance winner to next round
        const nextRound = m.round + 1;
        const nextMatchIdx = Math.floor(m.matchIdx / 2);
        const nextSlot = m.matchIdx % 2; // 0 = p1, 1 = p2
        const nextMatch = matches.find(x => x.round === nextRound && x.matchIdx === nextMatchIdx && !x.isThirdPlace);
        if (nextMatch) {
            if (nextSlot === 0) nextMatch.p1 = winner;
            else nextMatch.p2 = winner;
        }

        // Route semi-final losers to 3rd place match
        const thirdMatch = matches.find(x => x.isThirdPlace);
        if (thirdMatch) {
            const maxRound = Math.max(...matches.filter(x => !x.isThirdPlace).map(x => x.round));
            const semiRound = maxRound - 1;
            if (m.round === semiRound) {
                if (m.matchIdx === 0) thirdMatch.p1 = loser;
                else if (m.matchIdx === 1) thirdMatch.p2 = loser;
            }
        }
    }

    // Auto-resolve any BYE matches that became ready after this advancement
    autoResolveBracketBYEs(matches);

    saveState();
    renderInteractiveBracket();
    renderFinalsTabBar();
    showToast(`勝者：${winner}`, 'success');
}

function getBracketResults() {
    if (!state.activeCategory) return null;
    return getBracketResultsForCategory(state.activeCategory);
}

function renderBracketResult() {
    const area = document.getElementById('bracketResultArea');
    if (!area) return;
    area.innerHTML = '';

    const result = getBracketResults();
    if (!result) return;

    const resultCard = document.createElement('div');
    resultCard.className = 'bracket-result-card';
    resultCard.innerHTML = '<h3>比賽結果</h3>';

    let html = '<div class="medal-row">';
    html += `<div class="medal-item gold"><div class="medal-label">🥇 冠軍</div><div class="medal-name">${escapeXml(result.champion)}</div></div>`;
    html += `<div class="medal-item silver"><div class="medal-label">🥈 亞軍</div><div class="medal-name">${escapeXml(result.runnerUp)}</div></div>`;
    if (result.bronzes.length > 0) {
        html += `<div class="medal-item bronze"><div class="medal-label">🥉 季軍</div><div class="medal-name">${result.bronzes.map(b => escapeXml(b)).join('、')}</div></div>`;
    }
    if (result.fourth) {
        html += `<div class="medal-item" style="background:var(--bg-card);border:1.5px solid var(--border);"><div class="medal-label">殿軍</div><div class="medal-name">${escapeXml(result.fourth)}</div></div>`;
    }
    html += '</div>';
    html += '<div class="result-print-btn"><button class="btn btn-danger" onclick="printResultAnnouncement()">列印 / 下載成績公告</button></div>';

    resultCard.innerHTML += html;
    area.appendChild(resultCard);
}

function renderPrelimResultCard(cat) {
    const result = state.prelimResults[cat];
    if (!result) return;
    const bracketArea = document.getElementById('bracketArea');
    const card = document.createElement('div');
    card.className = 'card';
    card.style.marginTop = '16px';
    let html = '<h3 style="margin-bottom:12px;">比賽結果（預賽決定）</h3>';
    html += '<div class="medal-row">';
    html += `<div class="medal-item gold"><div class="medal-label">🥇 冠軍</div><div class="medal-name">${escapeXml(result.champion)}</div></div>`;
    html += `<div class="medal-item silver"><div class="medal-label">🥈 亞軍</div><div class="medal-name">${escapeXml(result.runnerUp)}</div></div>`;
    if (result.bronzes && result.bronzes.length > 0) {
        html += `<div class="medal-item bronze"><div class="medal-label">🥉 季軍</div><div class="medal-name">${result.bronzes.map(b => escapeXml(b)).join('、')}</div></div>`;
    }
    if (result.fourth) {
        html += `<div class="medal-item" style="background:var(--bg-card);border:1.5px solid var(--border);"><div class="medal-label">殿軍</div><div class="medal-name">${escapeXml(result.fourth)}</div></div>`;
    }
    html += '</div>';
    html += '<div class="result-print-btn"><button class="btn btn-danger" onclick="printResultAnnouncement()">列印 / 下載成績公告</button></div>';
    card.innerHTML = html;
    bracketArea.appendChild(card);
}

function printResultAnnouncement() {
    const result = getBracketResults();
    if (!result) { showToast('尚無比賽結果', 'error'); return; }

    const eventTitle = getEventTitle();
    const catPrefix = state.activeCategory ? state.activeCategory + ' ' : '';
    const finalTitle = catPrefix + (document.getElementById('finalTitle').value.trim() || '');
    const today = new Date();
    const dateStr = `${today.getFullYear()} 年 ${today.getMonth() + 1} 月 ${today.getDate()} 日`;

    const isDoubles = state.activeCategory && state.setupPool[state.activeCategory] && state.setupPool[state.activeCategory].type === '雙打';
    // Format doubles name: "學校 選手A 選手B" → "學校 選手A<br>學校 選手B"
    const fmtName = (name) => {
        if (!isDoubles || !name) return escapeXml(name || '');
        const parts = name.trim().split(/\s+/);
        if (parts.length >= 3) return escapeXml(parts[0] + ' ' + parts[1]) + '<br>' + escapeXml(parts[0] + ' ' + parts.slice(2).join(' '));
        return escapeXml(name);
    };

    // Collect all match results for the detail table
    const currentMatches = getCurrentBracketMatches() || [];
    const isPrelimOnly = currentMatches.length === 0 && state.prelimResults && state.prelimResults[state.activeCategory];
    const matchSource = isPrelimOnly ? state.prelimResults[state.activeCategory].matches : currentMatches;
    const matches = matchSource.filter(m => m.winner && m.p1 !== '—BYE—' && m.p2 !== '—BYE—' && m.p1 !== '—TBD—' && m.p2 !== '—TBD—');
    const rounds = isPrelimOnly ? 1 : getBracketRoundCount(currentMatches);

    const win = openPrintWindow();
    if (!win) return;
    const doc = win.document;
    doc.open();
    doc.write('<!DOCTYPE html><html><head><meta charset="UTF-8">');
    doc.write('<title>' + escapeXml(eventTitle) + ' 成績公告</title>');
    doc.write('<scr' + 'ipt src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></scr' + 'ipt>');
    doc.write('<scr' + 'ipt src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></scr' + 'ipt>');
    doc.write('<style>');
    doc.write('@media print { body { margin: 0; } .no-print { display: none !important; } }');
    doc.write('* { margin: 0; padding: 0; box-sizing: border-box; }');
    doc.write('body { font-family: "Microsoft JhengHei", "Noto Sans TC", sans-serif; background: #fff; color: #222; }');
    doc.write('.no-print { text-align: center; padding: 16px; background: #f5f5f5; border-bottom: 1px solid #ddd; }');
    doc.write('.no-print button, .no-print select { padding: 8px 16px; font-size: 14px; border-radius: 6px; cursor: pointer; margin: 0 4px; font-weight: 600; vertical-align: middle; }');
    doc.write('.no-print select { border: 1px solid #ccc; cursor: pointer; }');
    doc.write('.btn-print { background: #1a73e8; color: #fff; border: none; }');
    doc.write('.btn-pdf { background: #ea4335; color: #fff; border: none; }');
    doc.write('.announcement { max-width: 700px; margin: 0 auto; padding: 40px 50px; }');
    // Header with double border
    doc.write('.ann-header { text-align: center; padding-bottom: 24px; margin-bottom: 28px; border-bottom: 3px double #333; }');
    doc.write('.ann-event { font-size: 28px; font-weight: 900; letter-spacing: 4px; margin-bottom: 6px; }');
    doc.write('.ann-subtitle { font-size: 20px; font-weight: 700; letter-spacing: 2px; color: #444; margin-bottom: 8px; }');
    doc.write('.ann-date { font-size: 14px; color: #666; }');
    // Podium
    doc.write('.podium { display: flex; justify-content: center; align-items: flex-end; gap: 12px; margin: 32px 0; }');
    doc.write('.podium-item { text-align: center; border-radius: 8px; padding: 14px 12px; flex: 1; max-width: 200px; }');
    doc.write('.podium-item.gold { background: linear-gradient(180deg, #fff8e1, #ffe082); border: 2px solid #f9ab00; order: 2; transform: scale(1.1); }');
    doc.write('.podium-item.silver { background: linear-gradient(180deg, #fafafa, #e0e0e0); border: 2px solid #9e9e9e; order: 1; }');
    doc.write('.podium-item.bronze { background: linear-gradient(180deg, #fff3e0, #ffcc80); border: 2px solid #ef6c00; order: 3; }');
    doc.write('.podium-4th { text-align: center; margin: 16px auto 0; padding: 10px 20px; border: 1px solid #ddd; border-radius: 6px; display: inline-block; font-size: 14px; color: #555; }');
    doc.write('.podium-4th strong { font-size: 16px; color: #333; }');
    doc.write('.podium-rank { font-size: 28px; margin-bottom: 4px; }');
    doc.write('.podium-label { font-size: 13px; color: #555; font-weight: 600; margin-bottom: 4px; }');
    doc.write('.podium-name { font-size: 18px; font-weight: 900; word-break: keep-all; }');
    // Match detail table
    doc.write('.match-section { margin-top: 32px; }');
    doc.write('.match-section h3 { font-size: 16px; margin-bottom: 12px; padding-bottom: 6px; border-bottom: 2px solid #333; }');
    doc.write('table { width: 100%; border-collapse: collapse; font-size: 13px; }');
    doc.write('th { background: #f5f5f5; padding: 6px 8px; text-align: left; font-weight: 700; border-bottom: 2px solid #ddd; }');
    doc.write('td { padding: 6px 8px; border-bottom: 1px solid #eee; white-space: nowrap; }');
    doc.write('tr:last-child td { border-bottom: 2px solid #ddd; }');
    doc.write('.winner-cell { font-weight: 700; color: #1a73e8; }');
    doc.write('.score-cell { text-align: center; font-weight: 600; font-size: 14px; }');
    doc.write('.round-header td { background: #f9f9f9; font-weight: 700; color: #333; border-bottom: 1px solid #ddd; }');
    doc.write('tr { page-break-inside: avoid; }');
    doc.write('.podium { page-break-inside: avoid; }');
    // Footer
    doc.write('.ann-footer { margin-top: 36px; padding-top: 20px; border-top: 3px double #333; text-align: center; font-size: 13px; color: #888; }');
    doc.write('</style>');
    doc.write('<style id="orientStyle">@media print { @page { margin: 15mm; size: portrait; } }</style>');
    doc.write('</head><body>');

    // Toolbar
    doc.write('<div class="no-print">');
    doc.write('<select id="orientSelect" onchange="updateOrient()"><option value="portrait">直向</option><option value="landscape">橫向</option></select>');
    doc.write('<button class="btn-print" onclick="window.print()">列印</button>');
    doc.write('<button class="btn-pdf" onclick="downloadPDF()">下載 PDF</button>');
    doc.write('</div>');

    // Announcement body
    doc.write('<div class="announcement" id="annContent">');

    // Header
    doc.write('<div class="ann-header">');
    doc.write('<div class="ann-event">' + escapeXml(eventTitle) + '</div>');
    if (finalTitle) doc.write('<div class="ann-subtitle">' + escapeXml(finalTitle) + '</div>');
    doc.write('<div class="ann-subtitle">成績公告</div>');
    doc.write('<div class="ann-date">' + dateStr + '</div>');
    doc.write('</div>');

    // Podium
    doc.write('<div class="podium">');
    doc.write('<div class="podium-item silver"><div class="podium-rank">🥈</div><div class="podium-label">亞軍</div><div class="podium-name">' + fmtName(result.runnerUp) + '</div></div>');
    doc.write('<div class="podium-item gold"><div class="podium-rank">🥇</div><div class="podium-label">冠軍</div><div class="podium-name">' + fmtName(result.champion) + '</div></div>');
    if (result.bronzes.length > 0) {
        doc.write('<div class="podium-item bronze"><div class="podium-rank">🥉</div><div class="podium-label">季軍</div><div class="podium-name">' + result.bronzes.map(b => fmtName(b)).join('、') + '</div></div>');
    }
    doc.write('</div>');
    if (result.fourth) {
        if (isDoubles) {
            doc.write('<div style="text-align:center;"><div class="podium-4th">殿軍<br><strong>' + fmtName(result.fourth) + '</strong></div></div>');
        } else {
            doc.write('<div style="text-align:center;"><div class="podium-4th">殿軍<strong>' + fmtName(result.fourth) + '</strong></div></div>');
        }
    }

    // Match details table
    if (matches.length > 0) {
        doc.write('<div class="match-section">');
        doc.write('<h3>對戰明細</h3>');
        doc.write('<table>');
        doc.write('<tr><th>場次</th><th>選手</th><th style="text-align:center">比分</th><th>選手</th><th>勝者</th></tr>');

        let lastRound = -1;
        let matchNum = 1;
        let shown3rd = false;
        matches.forEach(m => {
            if (m.isThirdPlace) {
                if (!shown3rd) { doc.write('<tr class="round-header"><td colspan="5">季軍賽</td></tr>'); shown3rd = true; }
            } else if (m.isPrelim) {
                if (lastRound !== 'prelim') { lastRound = 'prelim'; doc.write('<tr class="round-header"><td colspan="5">預賽</td></tr>'); }
            } else if (m.round !== lastRound) {
                lastRound = m.round;
                const rn = getRoundName(m.round, rounds);
                doc.write('<tr class="round-header"><td colspan="5">' + rn + '</td></tr>');
            }
            const w = m.winner;
            const s = m.s1 && m.s2 ? m.s1 + ' : ' + m.s2 : '-';
            doc.write('<tr>');
            doc.write('<td>' + matchNum + '</td>');
            doc.write('<td' + (w === m.p1 ? ' class="winner-cell"' : '') + '>' + fmtName(m.p1) + '</td>');
            doc.write('<td class="score-cell">' + s + '</td>');
            doc.write('<td' + (w === m.p2 ? ' class="winner-cell"' : '') + '>' + fmtName(m.p2) + '</td>');
            doc.write('<td class="winner-cell">' + fmtName(w) + '</td>');
            doc.write('</tr>');
            matchNum++;
        });
        doc.write('</table>');
        doc.write('</div>');
    }

    // Footer
    doc.write('<div class="ann-footer">');
    doc.write(escapeXml(eventTitle) + ' 大會製');
    doc.write('</div>');

    doc.write('</div>'); // .announcement

    // PDF download script + orientation helpers
    doc.write('<scr' + 'ipt>');
    doc.write('function updateOrient(){var o=document.getElementById("orientSelect").value;document.getElementById("orientStyle").textContent="@media print{@page{margin:15mm;size:"+o+";}}";}');
    doc.write('function getOrient(){return document.getElementById("orientSelect").value;}');
    doc.write('function downloadPDF() {');
    doc.write('  var el = document.getElementById("annContent");');
    doc.write('  html2canvas(el, { scale: 2, useCORS: true, backgroundColor: "#fff" }).then(function(cv) {');
    doc.write('    var imgData = cv.toDataURL("image/jpeg", 0.92);');
    doc.write('    var orient = getOrient();');
    doc.write('    var pdf = new jspdf.jsPDF({ orientation: orient, unit: "mm", format: "a4", compress: true });');
    doc.write('    var pw = orient==="landscape"?297:210, ph = orient==="landscape"?210:297, m = 10;');
    doc.write('    var uw = pw - m * 2, uh = ph - m * 2;');
    doc.write('    var r = Math.min(uw / cv.width, uh / cv.height);');
    doc.write('    var iw = cv.width * r, ih = cv.height * r;');
    doc.write('    pdf.addImage(imgData, "JPEG", m + (uw - iw) / 2, m, iw, ih, undefined, "FAST");');
    doc.write('    pdf.save("' + escapeXml(eventTitle) + ' 成績公告.pdf");');
    doc.write('  });');
    doc.write('}');
    doc.write('</scr' + 'ipt>');

    doc.write('</body></html>');
    doc.close();
}

// ============================================================
// Combined Full Report (prelim + finals)
// ============================================================
function _writeReportCSS(doc) {
    doc.write('<style>');
    doc.write('@media print { body { margin: 0; } .no-print { display: none !important; } }');
    doc.write('* { margin: 0; padding: 0; box-sizing: border-box; }');
    doc.write('body { font-family: "Microsoft JhengHei", "Noto Sans TC", sans-serif; background: #fff; color: #222; font-size: 13px; }');
    doc.write('.no-print { text-align: center; padding: 12px; background: #f5f5f5; border-bottom: 1px solid #ddd; position: sticky; top: 0; z-index: 10; }');
    doc.write('.no-print button, .no-print select { padding: 8px 16px; font-size: 14px; border-radius: 6px; cursor: pointer; margin: 0 4px; font-weight: 600; vertical-align: middle; }');
    doc.write('.no-print select { border: 1px solid #ccc; cursor: pointer; }');
    doc.write('.btn-print { background: #1a73e8; color: #fff; } .btn-pdf { background: #ea4335; color: #fff; }');
    doc.write('.report { max-width: 800px; margin: 0 auto; padding: 30px 40px; }');
    doc.write('.rpt-header { text-align: center; padding-bottom: 20px; margin-bottom: 24px; border-bottom: 3px double #333; }');
    doc.write('.rpt-event { font-size: 26px; font-weight: 900; letter-spacing: 3px; margin-bottom: 4px; }');
    doc.write('.rpt-subtitle { font-size: 18px; font-weight: 700; color: #444; margin-bottom: 6px; }');
    doc.write('.rpt-date { font-size: 13px; color: #666; }');
    doc.write('.section { margin-bottom: 24px; }');
    doc.write('.section h2 { font-size: 18px; color: #1a73e8; border-bottom: 2px solid #1a73e8; padding-bottom: 6px; margin-bottom: 12px; }');
    doc.write('.section h3 { font-size: 15px; color: #333; margin: 12px 0 8px; }');
    doc.write('table { width: 100%; border-collapse: collapse; margin-bottom: 12px; }');
    doc.write('th { background: #f5f5f5; padding: 6px 8px; text-align: left; font-weight: 700; border-bottom: 2px solid #ddd; font-size: 12px; }');
    doc.write('td { padding: 5px 8px; border-bottom: 1px solid #eee; font-size: 12px; }');
    doc.write('tr.qualified { background: #e6f4ea; } tr.qualified td:first-child { font-weight: 700; color: #137333; }');
    doc.write('tr { page-break-inside: avoid; }');
    doc.write('.section { page-break-inside: avoid; }');
    doc.write('.note-forfeit { color: #ea4335; font-weight: 600; } .note-injury { color: #e67e00; font-weight: 600; }');
    doc.write('.podium { display: flex; justify-content: center; gap: 12px; margin: 16px 0; flex-wrap: wrap; page-break-inside: avoid; }');
    doc.write('.podium-item { text-align: center; border-radius: 8px; padding: 12px 10px; min-width: 120px; flex: 1; max-width: 200px; }');
    doc.write('.podium-item.gold { background: linear-gradient(180deg, #fff8e1, #ffe082); border: 2px solid #f9ab00; }');
    doc.write('.podium-item.silver { background: linear-gradient(180deg, #fafafa, #e0e0e0); border: 2px solid #9e9e9e; }');
    doc.write('.podium-item.bronze { background: linear-gradient(180deg, #fff3e0, #ffcc80); border: 2px solid #ef6c00; }');
    doc.write('.podium-rank { font-size: 24px; margin-bottom: 2px; }');
    doc.write('.podium-label { font-size: 12px; color: #555; font-weight: 600; }');
    doc.write('.podium-name { font-size: 16px; font-weight: 900; word-break: keep-all; }');
    doc.write('.winner-cell { font-weight: 700; color: #1a73e8; } .score-cell { text-align: center; font-weight: 600; }');
    doc.write('.round-header td { background: #f9f9f9; font-weight: 700; border-bottom: 1px solid #ddd; }');
    doc.write('.rpt-footer { margin-top: 28px; padding-top: 16px; border-top: 3px double #333; text-align: center; font-size: 13px; color: #888; }');
    doc.write('</style>');
    doc.write('<style id="orientStyle">@media print { @page { margin: 12mm; size: portrait; } }</style>');
}

function _writeReportPrelimSection(doc) {
    doc.write('<div class="section"><h2>預賽成績</h2>');
    for (const cat in state.activeGroups) {
        const groups = state.activeGroups[cat];
        const totalInCat = groups.reduce((s, g) => s + g.members.length, 0);
        doc.write('<h3>' + escapeXml(cat) + '（共 ' + totalInCat + ' 人）</h3>');

        groups.forEach(group => {
            const { scores, hasScore } = getScores(cat, group);
            if (!hasScore) return;

            const nQ = getQualifyCount(group.members.length, totalInCat);
            const { voluntary: voluntaryPlayers, injury: injuryPlayers } = collectForfeitPlayers(group);

            const ranked = rankPlayers(scores);

            doc.write('<div style="margin-bottom:8px;font-size:13px;font-weight:600;color:#555;">' + escapeXml(group.name) + ' 組（' + group.members.length + ' 人）</div>');
            doc.write('<table><tr><th>排名</th><th>選手</th><th>勝</th><th>負</th><th>得分</th><th>失分</th><th>淨分</th><th>備註</th></tr>');

            ranked.forEach(([idx, s], rank) => {
                const isQ = rank < nQ;
                const isV = voluntaryPlayers.has(parseInt(idx));
                const isI = injuryPlayers.has(parseInt(idx));
                let note = isV ? '<span class="note-forfeit">棄</span>' : (isI ? '<span class="note-injury">傷</span>' : '');

                doc.write('<tr' + (isQ ? ' class="qualified"' : '') + '>');
                doc.write('<td>' + (rank + 1) + '</td>');
                doc.write('<td>' + escapeXml(group.members[parseInt(idx)]) + '</td>');
                doc.write('<td>' + s.wins + '</td><td>' + s.losses + '</td>');
                doc.write('<td>' + s.pf + '</td><td>' + s.pa + '</td><td>' + (s.pf - s.pa) + '</td>');
                doc.write('<td>' + note + '</td></tr>');
            });
            doc.write('</table>');
        });
    }
    doc.write('</div>');
}

function _writeReportFinalsSection(doc) {
    const cats = getFinalsCategories();
    cats.forEach(cat => {
        const bracketResult = getBracketResultsForCategory(cat);
        if (!bracketResult) return;
        const isDoubles = state.setupPool[cat] && state.setupPool[cat].type === '雙打';
        const fmtName = (name) => {
            if (!isDoubles || !name) return escapeXml(name || '');
            const parts = name.trim().split(/\s+/);
            if (parts.length >= 3) return escapeXml(parts[0] + ' ' + parts[1]) + '<br>' + escapeXml(parts[0] + ' ' + parts.slice(2).join(' '));
            return escapeXml(name);
        };
        const isCatPrelim = state.prelimResults && state.prelimResults[cat] && (!state.bracketMatches[cat] || state.bracketMatches[cat].length === 0);
        doc.write('<div class="section"><h2>' + escapeXml(cat) + (isCatPrelim ? ' 成績' : ' 決賽成績') + '</h2>');
        // Podium
        doc.write('<div class="podium">');
        doc.write('<div class="podium-item gold"><div class="podium-rank">🥇</div><div class="podium-label">冠軍</div><div class="podium-name">' + fmtName(bracketResult.champion) + '</div></div>');
        doc.write('<div class="podium-item silver"><div class="podium-rank">🥈</div><div class="podium-label">亞軍</div><div class="podium-name">' + fmtName(bracketResult.runnerUp) + '</div></div>');
        if (bracketResult.bronzes.length > 0) {
            doc.write('<div class="podium-item bronze"><div class="podium-rank">🥉</div><div class="podium-label">季軍</div><div class="podium-name">' + bracketResult.bronzes.map(b => fmtName(b)).join('、') + '</div></div>');
        }
        doc.write('</div>');
        if (bracketResult.fourth) {
            if (isDoubles) {
                doc.write('<div style="text-align:center;margin-bottom:12px;"><span style="border:1px solid #ddd;border-radius:6px;padding:6px 16px;font-size:13px;color:#555;">殿軍<br><strong>' + fmtName(bracketResult.fourth) + '</strong></span></div>');
            } else {
                doc.write('<div style="text-align:center;margin-bottom:12px;"><span style="border:1px solid #ddd;border-radius:6px;padding:6px 16px;font-size:13px;color:#555;">殿軍<strong>' + fmtName(bracketResult.fourth) + '</strong></span></div>');
            }
        }
        // Match details — use bracket matches or prelim matches
        const catMatches = state.bracketMatches[cat] || [];
        const isPrelimCat = catMatches.length === 0 && state.prelimResults && state.prelimResults[cat];
        const matchSource = isPrelimCat ? state.prelimResults[cat].matches : catMatches;
        const fMatches = matchSource.filter(m => m.winner && m.p1 !== '—BYE—' && m.p2 !== '—BYE—' && m.p1 !== '—TBD—' && m.p2 !== '—TBD—');
        if (fMatches.length > 0) {
            const rounds = isPrelimCat ? 1 : getBracketRoundCount(catMatches);
            doc.write('<h3>對戰明細</h3>');
            doc.write('<table><tr><th>場次</th><th>選手</th><th style="text-align:center">比分</th><th>選手</th><th>勝者</th></tr>');
            let lastRound = -1, matchNum = 1, shown3rd = false;
            fMatches.forEach(m => {
                if (m.isThirdPlace) {
                    if (!shown3rd) { doc.write('<tr class="round-header"><td colspan="5">季軍賽</td></tr>'); shown3rd = true; }
                } else if (m.isPrelim) {
                    if (lastRound !== 'prelim') { lastRound = 'prelim'; doc.write('<tr class="round-header"><td colspan="5">預賽</td></tr>'); }
                } else if (m.round !== lastRound) {
                    lastRound = m.round;
                    doc.write('<tr class="round-header"><td colspan="5">' + getRoundName(m.round, rounds) + '</td></tr>');
                }
                const w = m.winner;
                const s = m.s1 && m.s2 ? m.s1 + ' : ' + m.s2 : '-';
                doc.write('<tr><td>' + matchNum + '</td>');
                doc.write('<td' + (w === m.p1 ? ' class="winner-cell"' : '') + '>' + fmtName(m.p1) + '</td>');
                doc.write('<td class="score-cell">' + s + '</td>');
                doc.write('<td' + (w === m.p2 ? ' class="winner-cell"' : '') + '>' + fmtName(m.p2) + '</td>');
                doc.write('<td class="winner-cell">' + fmtName(w) + '</td></tr>');
                matchNum++;
            });
            doc.write('</table>');
        }
        doc.write('</div>');
    });
}

function _writeReportPDFScript(doc, pdfTitle) {
    doc.write('<scr' + 'ipt>');
    doc.write('function updateOrient(){var o=document.getElementById("orientSelect").value;document.getElementById("orientStyle").textContent="@media print{@page{margin:12mm;size:"+o+";}}";}');
    doc.write('function getOrient(){return document.getElementById("orientSelect").value;}');
    doc.write('function downloadPDF() {');
    doc.write('  var el = document.getElementById("reportContent");');
    doc.write('  var orient = getOrient();');
    doc.write('  html2canvas(el, { scale: 2, useCORS: true, backgroundColor: "#fff" }).then(function(cv) {');
    doc.write('    var imgData = cv.toDataURL("image/jpeg", 0.92);');
    doc.write('    var pdf = new jspdf.jsPDF({ orientation: orient, unit: "mm", format: "a4", compress: true });');
    doc.write('    var pw = orient==="landscape"?297:210, ph = orient==="landscape"?210:297, m = 10, uw = pw - m * 2, uh = ph - m * 2;');
    doc.write('    var r = Math.min(uw / cv.width, uh / cv.height);');
    doc.write('    var iw = cv.width * r, ih = cv.height * r;');
    doc.write('    if (ih > uh) {');
    doc.write('      var pages = Math.ceil(ih / uh);');
    doc.write('      for (var p = 0; p < pages; p++) { if (p > 0) pdf.addPage("a4",orient); pdf.addImage(imgData, "JPEG", m, m - (p * uh), iw, ih, undefined, "FAST"); }');
    doc.write('    } else { pdf.addImage(imgData, "JPEG", m + (uw - iw) / 2, m, iw, ih, undefined, "FAST"); }');
    doc.write('    pdf.save("' + escapeXml(pdfTitle) + '.pdf");');
    doc.write('  });');
    doc.write('}');
    doc.write('</scr' + 'ipt>');
}

function generateFullReport() {
    if (Object.keys(state.activeGroups).length === 0) { showToast('尚無預賽資料', 'error'); return; }

    const eventTitle = getEventTitle();
    const today = new Date();
    const dateStr = `${today.getFullYear()} 年 ${today.getMonth() + 1} 月 ${today.getDate()} 日`;
    const hasAnyResult = getFinalsCategories().some(cat => getBracketResultsForCategory(cat));

    const win = openPrintWindow();
    if (!win) return;
    const doc = win.document;
    doc.open();
    doc.write('<!DOCTYPE html><html><head><meta charset="UTF-8">');
    doc.write('<title>' + escapeXml(eventTitle) + ' 綜合成績報表</title>');
    doc.write('<scr' + 'ipt src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></scr' + 'ipt>');
    doc.write('<scr' + 'ipt src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></scr' + 'ipt>');
    _writeReportCSS(doc);
    doc.write('</head><body>');

    doc.write('<div class="no-print"><select id="orientSelect" onchange="updateOrient()"><option value="portrait">直向</option><option value="landscape">橫向</option></select><button class="btn-print" onclick="window.print()">列印</button><button class="btn-pdf" onclick="downloadPDF()">下載 PDF</button></div>');
    doc.write('<div class="report" id="reportContent">');
    doc.write('<div class="rpt-header"><div class="rpt-event">' + escapeXml(eventTitle) + '</div><div class="rpt-subtitle">綜合成績報表</div><div class="rpt-date">' + dateStr + '</div></div>');

    _writeReportPrelimSection(doc);
    if (hasAnyResult) _writeReportFinalsSection(doc);

    doc.write('<div class="rpt-footer">' + escapeXml(eventTitle) + ' 大會製</div>');
    doc.write('</div>');

    _writeReportPDFScript(doc, eventTitle + ' 綜合成績報表');

    doc.write('</body></html>');
    doc.close();
}

function generateFinalsScoreTable() {
    const qualifiers = getCurrentFinalQualifiers();
    if (qualifiers.length < 2) { showToast('至少需要 2 位選手', 'error'); return; }

    const realPlayers = qualifiers.map(q => q.name);
    const size = Math.pow(2, Math.ceil(Math.log2(realPlayers.length)));
    const seedOrd = bracketSeedOrder(size);
    const players = new Array(size);
    for (let pos = 0; pos < size; pos++) players[pos] = seedOrd[pos] < realPlayers.length ? realPlayers[seedOrd[pos]] : '—BYE—';
    const rounds = Math.log2(size);
    const title = document.getElementById('finalTitle').value.trim() || '決賽對戰表';

    // Build first round pairings
    let currentRound = [];
    for (let i = 0; i < players.length; i += 2) currentRound.push([players[i], players[i + 1]]);

    // Build all rounds data
    const allRounds = [];
    for (let r = 0; r < rounds; r++) {
        const rName = getRoundName(r, rounds);
        const matches = currentRound.map(([p1, p2], mi) => {
            const bye1 = p1 === '—BYE—', bye2 = p2 === '—BYE—';
            return { p1, p2, bye1, bye2, id: 'fsr' + r + 'm' + mi };
        });
        allRounds.push({ name: rName, matches });
        const next = [];
        for (let i = 0; i < currentRound.length; i += 2) {
            const w1 = currentRound[i][0] === '—BYE—' ? currentRound[i][1] : (currentRound[i][1] === '—BYE—' ? currentRound[i][0] : null);
            const w2 = (i + 1 < currentRound.length) ? (currentRound[i + 1][0] === '—BYE—' ? currentRound[i + 1][1] : (currentRound[i + 1][1] === '—BYE—' ? currentRound[i + 1][0] : null)) : null;
            next.push([w1 || '待定', w2 || '待定']);
        }
        currentRound = next;
    }

    // Collect all player names for alignment
    const allNames = players.filter(p => p !== '—BYE—');
    const aw = getAlignWidths(allNames);

    const area = document.getElementById('finalsScoreArea');
    area.innerHTML = '';
    const card = document.createElement('div');
    card.className = 'card';
    card.innerHTML = '<h3>' + escapeXml(title) + ' — 評分表</h3>';

    allRounds.forEach((round, ri) => {
        const hasBye = round.matches.every(m => m.bye1 || m.bye2);
        if (hasBye && ri === 0 && rounds > 1) return; // skip pure-bye first round

        const section = document.createElement('div');
        section.className = 'group-card';
        section.innerHTML = '<h4>' + escapeXml(round.name) + '</h4>';

        round.matches.forEach((m, mi) => {
            if (m.bye1 && m.bye2) return;
            const matchNo = ri * 100 + mi + 1;
            const row = document.createElement('div');
            row.className = 'match-row';
            const p1Display = m.bye1 ? '<span style="color:var(--text-placeholder)">輪空</span>' : alignName(m.p1, aw.sw, aw.nw);
            const p2Display = m.bye2 ? '<span style="color:var(--text-placeholder)">輪空</span>' : alignName(m.p2, aw.sw, aw.nw);
            const disabled1 = m.bye1 ? ' disabled' : '';
            const disabled2 = m.bye2 ? ' disabled' : '';
            const ffBadge1 = m.bye1 ? '' : '<span class="ff-badge" id="ff1_' + m.id + '" data-ff="" onclick="cycleForfeit(\'' + m.id + '\',1)" tabindex="0" role="button" title="點擊切換：傷/棄">棄</span>';
            const ffBadge2 = m.bye2 ? '' : '<span class="ff-badge" id="ff2_' + m.id + '" data-ff="" onclick="cycleForfeit(\'' + m.id + '\',2)" tabindex="0" role="button" title="點擊切換：傷/棄">棄</span>';
            row.innerHTML =
                '<span class="match-no">' + (mi + 1) + '</span>' +
                '<span class="player-name" id="pn1_' + m.id + '">' + p1Display + ffBadge1 + '</span>' +
                '<input type="number" class="score-input" id="s1_' + m.id + '" min="0" max="99" placeholder="-"' + disabled1 + '>' +
                '<span class="vs-label">VS</span>' +
                '<input type="number" class="score-input" id="s2_' + m.id + '" min="0" max="99" placeholder="-"' + disabled2 + '>' +
                '<span class="player-name right" id="pn2_' + m.id + '">' + ffBadge2 + p2Display + '</span>';
            section.appendChild(row);
        });

        card.appendChild(section);
    });

    area.appendChild(card);
    showToast('已產生決賽評分表', 'success');
}

function printFinalsBracketPDF() {
    const qualifiers = getCurrentFinalQualifiers();
    if (qualifiers.length < 2) { showToast('至少需要 2 位選手', 'error'); return; }

    const catPrefix = state.activeCategory ? state.activeCategory + ' ' : '';
    const title = catPrefix + (document.getElementById('finalTitle').value.trim() || '決賽對戰圖');
    const isDoubles = state.activeCategory && state.setupPool[state.activeCategory] && state.setupPool[state.activeCategory].type === '雙打';
    const br = buildBracketSVG(qualifiers, 800, isDoubles);
    const svgW = br.width || 800;

    // Build full SVG with title header
    const headerH = 50;
    const svgH = br.height + headerH + 20;
    let fullSvg = '';
    fullSvg += '<text x="' + (svgW / 2) + '" y="28" text-anchor="middle" font-size="18" font-weight="bold" font-family="Microsoft JhengHei, sans-serif" fill="#000">' + escapeXml(title) + '</text>';
    fullSvg += '<g transform="translate(0,' + headerH + ')">' + br.svg + '</g>';

    const win = openPrintWindow();
    if (!win) return;
    const doc = win.document;
    doc.open();
    doc.write('<!DOCTYPE html><html><head><meta charset="UTF-8"><title>' + escapeXml(title) + '</title>');
    doc.write('<scr' + 'ipt src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></scr' + 'ipt>');
    doc.write('<style>');
    doc.write('body { font-family: "Microsoft JhengHei", sans-serif; background: #fff; margin: 20px; }');
    doc.write('.no-print { text-align: center; margin-bottom: 16px; }');
    doc.write('.no-print button, .no-print select { padding: 8px 16px; font-size: 14px; border-radius: 6px; cursor: pointer; margin: 0 4px; font-weight: 600; vertical-align: middle; }');
    doc.write('.no-print select { border: 1px solid #ccc; cursor: pointer; }');
    doc.write('.btn-print { background: #1a73e8; color: #fff; border: none; }');
    doc.write('.btn-pdf { background: #ea4335; color: #fff; border: none; }');
    doc.write('svg { display: block; margin: 0 auto; max-width: 100%; }');
    doc.write('@media print { body { margin: 0; } .no-print { display: none; } }');
    doc.write('</style>');
    doc.write('<style id="orientStyle">@media print { @page { margin: 8mm; size: landscape; } svg { max-height: 190mm; width: auto; height: auto; } }</style>');
    doc.write('</head><body>');
    doc.write('<div class="no-print">');
    doc.write('<select id="orientSelect" onchange="updateOrient()"><option value="landscape">橫向</option><option value="portrait">直向</option></select>');
    doc.write('<button class="btn-print" onclick="window.print()">列印</button>');
    doc.write('<button class="btn-pdf" onclick="downloadPDF()">下載 PDF</button>');
    doc.write('</div>');
    doc.write('<svg id="bracketSvg" xmlns="http://www.w3.org/2000/svg" width="' + svgW + '" height="' + svgH + '" viewBox="0 0 ' + svgW + ' ' + svgH + '">');
    doc.write('<rect width="100%" height="100%" fill="white"/>');
    doc.write(fullSvg);
    doc.write('</svg>');

    doc.write('<scr' + 'ipt>');
    doc.write('function updateOrient(){var o=document.getElementById("orientSelect").value;var h=o==="landscape"?"190mm":"275mm";document.getElementById("orientStyle").textContent="@media print{@page{margin:8mm;size:"+o+";}svg{max-height:"+h+";width:auto;height:auto;}}";}');
    doc.write('function getOrient(){return document.getElementById("orientSelect").value;}');
    doc.write('function downloadPDF() {');
    doc.write('  if (typeof jspdf === "undefined") { alert("PDF 元件載入中，請稍後再試"); return; }');
    doc.write('  var el = document.getElementById("bracketSvg");');
    doc.write('  var data = new XMLSerializer().serializeToString(el);');
    doc.write('  var blob = new Blob([data], {type:"image/svg+xml;charset=utf-8"});');
    doc.write('  var url = URL.createObjectURL(blob);');
    doc.write('  var img = new Image();');
    doc.write('  img.onload = function() {');
    doc.write('    var sc = 1.5;');
    doc.write('    var cv = document.createElement("canvas");');
    doc.write('    cv.width = img.width * sc; cv.height = img.height * sc;');
    doc.write('    var ctx = cv.getContext("2d");');
    doc.write('    ctx.fillStyle = "#fff"; ctx.fillRect(0,0,cv.width,cv.height);');
    doc.write('    ctx.scale(sc,sc); ctx.drawImage(img,0,0);');
    doc.write('    var imgData = cv.toDataURL("image/jpeg",0.75);');
    doc.write('    URL.revokeObjectURL(url);');
    doc.write('    var orient = getOrient();');
    doc.write('    var pdf = new jspdf.jsPDF({orientation:orient,unit:"mm",format:"a4",compress:true});');
    doc.write('    var pw = orient==="landscape"?297:210, ph = orient==="landscape"?210:297;');
    doc.write('    var m=8, uw=pw-m*2, uh=ph-m*2;');
    doc.write('    var r = Math.min(uw/img.width, uh/img.height);');
    doc.write('    var imgW = img.width*r, imgH = img.height*r;');
    doc.write('    if (imgH > uh + 1) {');
    doc.write('      var pages = Math.ceil(imgH / uh);');
    doc.write('      for (var p = 0; p < pages; p++) {');
    doc.write('        if (p > 0) pdf.addPage("a4",orient);');
    doc.write('        pdf.addImage(imgData,"JPEG",m+(uw-imgW)/2, m - p*uh, imgW, imgH, undefined,"FAST");');
    doc.write('      }');
    doc.write('    } else {');
    doc.write('      pdf.addImage(imgData,"JPEG",m+(uw-imgW)/2, m+(uh-imgH)/2, imgW, imgH, undefined,"FAST");');
    doc.write('    }');
    doc.write('    pdf.save("' + escapeXml(title) + '.pdf");');
    doc.write('  };');
    doc.write('  img.src = url;');
    doc.write('}');
    doc.write('</scr' + 'ipt>');
    doc.write('</body></html>');
    doc.close();
}

// ============================================================
// Match Sheets (出賽單)
// ============================================================
function splitDoubles(name) {
    if (name.includes('/')) return name.split('/').map(s => s.trim());
    const parts = name.trim().split(/\s+/);
    if (parts.length >= 3) return [parts[parts.length - 2], parts[parts.length - 1]];
    if (parts.length === 2) return [parts[0], parts[1]];
    return [name];
}

async function generatePrelimSheets() {
    if (Object.keys(state.activeGroups).length === 0) { showToast('尚無比賽資料', 'error'); return; }
    const title = await customPrompt('請輸入賽事名稱', getEventTitle());
    if (!title) return;

    const matches = [];
    for (const cat in state.activeGroups) {
        const isDoubles = state.setupPool[cat] && state.setupPool[cat].type === '雙打';
        state.activeGroups[cat].forEach(group => {
            group.matches.forEach(m => {
                const p1Name = group.members[m.p1];
                const p2Name = group.members[m.p2];
                matches.push({
                    matchNo: m.matchNo,
                    category: cat + ' ' + group.name + '組',
                    p1: isDoubles ? splitDoubles(p1Name) : [p1Name],
                    p2: isDoubles ? splitDoubles(p2Name) : [p2Name],
                    isDoubles
                });
            });
        });
    }
    openMatchSheets(matches, title);
}

async function generateFinalsSheets() {
    const qualifiers = getCurrentFinalQualifiers();
    if (qualifiers.length < 2) { showToast('至少需要 2 位選手', 'error'); return; }
    const catPrefix = state.activeCategory ? state.activeCategory + ' ' : '';
    const title = await customPrompt('請輸入賽事名稱', catPrefix + (document.getElementById('finalTitle').value.trim() || getEventTitle()));
    if (!title) return;
    const isDoubles = state.activeCategory && state.setupPool[state.activeCategory] && state.setupPool[state.activeCategory].type === '雙打';

    const realPlayers2 = qualifiers.map(q => q.name);
    const size = Math.pow(2, Math.ceil(Math.log2(realPlayers2.length)));
    const seedOrd2 = bracketSeedOrder(size);
    const players = new Array(size);
    for (let pos = 0; pos < size; pos++) players[pos] = seedOrd2[pos] < realPlayers2.length ? realPlayers2[seedOrd2[pos]] : '—BYE—';
    const rounds = Math.log2(size);

    let currentRound = [];
    for (let i = 0; i < players.length; i += 2) currentRound.push([players[i], players[i + 1]]);

    // Get global match number start
    let matchNo = 1;
    for (const cat in state.activeGroups) {
        state.activeGroups[cat].forEach(g => {
            g.matches.forEach(m => { if (m.matchNo >= matchNo) matchNo = m.matchNo + 1; });
        });
    }

    const matches = [];
    for (let r = 0; r < rounds; r++) {
        const rName = getRoundName(r, rounds);
        currentRound.forEach(([p1, p2]) => {
            if (p1 === '—BYE—' || p2 === '—BYE—') { return; }
            matches.push({
                matchNo: matchNo++,
                category: '決賽 ' + rName,
                p1: isDoubles ? splitDoubles(p1) : [p1],
                p2: isDoubles ? splitDoubles(p2) : [p2],
                isDoubles
            });
        });
        const next = [];
        for (let i = 0; i < currentRound.length; i += 2) {
            const w1 = currentRound[i][0] === '—BYE—' ? currentRound[i][1] : (currentRound[i][1] === '—BYE—' ? currentRound[i][0] : '待定');
            const w2 = (i + 1 < currentRound.length) ? (currentRound[i + 1][0] === '—BYE—' ? currentRound[i + 1][1] : (currentRound[i + 1][1] === '—BYE—' ? currentRound[i + 1][0] : '待定')) : '待定';
            next.push([w1, w2]);
        }
        currentRound = next;
    }
    // Add 3rd-place match if applicable
    if (realPlayers2.length >= 4 && rounds >= 2) {
        matches.push({
            matchNo: matchNo++,
            category: '決賽 季軍賽',
            p1: ['待定'],
            p2: ['待定'],
            isDoubles
        });
    }
    openMatchSheets(matches, title);
}

function openMatchSheets(matches, title) {
    const win = openPrintWindow();
    if (!win) return;
    const doc = win.document;
    doc.open();
    doc.write('<!DOCTYPE html><html><head><meta charset="UTF-8"><title>出賽單</title>');
    doc.write('<scr' + 'ipt src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></scr' + 'ipt>');
    doc.write('<scr' + 'ipt src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></scr' + 'ipt>');
    doc.write('<style>');
    doc.write('* { box-sizing: border-box; margin: 0; padding: 0; }');
    doc.write('body { font-family: "Microsoft JhengHei", "PMingLiU", sans-serif; }');
    doc.write('.no-print { text-align: center; padding: 16px; }');
    doc.write('.no-print button { padding: 10px 24px; font-size: 15px; border: none; border-radius: 6px; cursor: pointer; margin: 0 6px; font-weight: 600; }');
    doc.write('.btn-print { background: #1a73e8; color: #fff; }');
    doc.write('.btn-pdf { background: #ea4335; color: #fff; }');
    doc.write('.sheet-page { width: 210mm; height: 297mm; margin: 0 auto; padding: 0; display: flex; flex-direction: column; }');
    doc.write('.sheet { width: 100%; height: 148.5mm; padding: 8mm 15mm; border-bottom: 1px dashed #999; display: flex; flex-direction: column; justify-content: space-between; overflow: hidden; }');
    doc.write('.sheet:last-child { border-bottom: none; }');
    doc.write('.sheet-title { text-align: center; font-size: 18px; font-weight: bold; margin-bottom: 2px; }');
    doc.write('.sheet-subtitle { text-align: center; font-size: 16px; font-weight: bold; margin-bottom: 8px; letter-spacing: 6px; }');
    doc.write('.sheet-info { display: flex; justify-content: space-between; margin-bottom: 8px; font-size: 13px; line-height: 1.9; }');
    doc.write('.sheet-info .left, .sheet-info .right { width: 48%; }');
    doc.write('.sheet-info .blank { display: inline-block; border-bottom: 1px solid #333; min-width: 80px; }');
    doc.write('.blank-sm { display: inline-block; border-bottom: 1px solid #333; min-width: 50px; }');
    doc.write('.match-area { display: flex; align-items: center; justify-content: center; gap: 20px; margin: 8px 0; }');
    doc.write('.player-box { border: 2px solid #333; min-width: 140px; }');
    doc.write('.slot-row { display: flex; }');
    doc.write('.slot-row + .slot-row { border-top: 1px solid #333; }');
    doc.write('.slot-row .slot-left { padding: 6px 4px; min-height: 34px; min-width: 22px; border-right: 1px solid #333; }');
    doc.write('.slot-row .slot-name { padding: 6px 16px; font-size: 15px; font-weight: bold; text-align: center; min-height: 34px; flex: 1; }');
    doc.write('.score-area { text-align: center; }');
    doc.write('.score-label { font-size: 13px; margin-bottom: 4px; }');
    doc.write('.score-boxes { display: flex; align-items: center; gap: 6px; }');
    doc.write('.score-box { width: 48px; height: 34px; border: 2px solid #333; }');
    doc.write('.score-colon { font-size: 20px; font-weight: bold; }');
    doc.write('.sheet-footer { font-size: 13px; display: flex; gap: 16px; }');
    doc.write('.sheet-footer .f-item { flex: 1; }');
    doc.write('.sheet-footer .f-line { display: inline-block; border-bottom: 1px solid #333; width: 75%; }');
    doc.write('@media print { .no-print { display: none; } @page { margin: 0; size: A4; } .sheet-page { page-break-after: always; height: 297mm; } .sheet-page:last-child { page-break-after: auto; } }');
    doc.write('</style></head><body>');
    doc.write('<div class="no-print">');
    doc.write('<button class="btn-print" onclick="window.print()">列印</button>');
    doc.write('<button class="btn-pdf" onclick="downloadPDF()">下載 PDF</button>');
    doc.write('</div>');

    // 2 sheets per page
    for (let i = 0; i < matches.length; i += 2) {
        doc.write('<div class="sheet-page">');
        for (let j = i; j < Math.min(i + 2, matches.length); j++) {
            const m = matches[j];
            doc.write('<div class="sheet">');
            doc.write('<div class="sheet-title">' + escapeXml(title) + '</div>');
            doc.write('<div class="sheet-subtitle">出賽單</div>');
            doc.write('<div class="sheet-info">');
            doc.write('<div class="left">');
            doc.write('<div>日期 <span class="blank">&nbsp;</span>/<span class="blank">&nbsp;</span>/<span class="blank">&nbsp;</span></div>');
            doc.write('<div>時間 <span class="blank-sm">&nbsp;</span>:<span class="blank-sm">&nbsp;</span></div>');
            doc.write('<div>場次 <b>' + m.matchNo + '</b></div>');
            doc.write('<div>場地 <span class="blank" style="min-width:140px;">&nbsp;</span></div>');
            doc.write('</div>');
            doc.write('<div class="right">');
            doc.write('<div>開始時間 <span class="blank-sm">&nbsp;</span>:<span class="blank-sm">&nbsp;</span> 用球數 <span class="blank-sm">&nbsp;</span></div>');
            doc.write('<div>結束時間 <span class="blank-sm">&nbsp;</span>:<span class="blank-sm">&nbsp;</span></div>');
            doc.write('<div>使用時間 <span class="blank-sm">&nbsp;</span>:<span class="blank-sm">&nbsp;</span></div>');
            doc.write('</div>');
            doc.write('</div>');

            // Match area
            doc.write('<div class="match-area">');
            // Left player box
            doc.write('<div class="player-box">');
            m.p1.forEach(name => {
                doc.write('<div class="slot-row"><div class="slot-left"></div><div class="slot-name">' + escapeXml(name) + '</div></div>');
            });
            if (!m.isDoubles && m.p1.length === 1) {
                // Singles: just 1 row, keep box consistent
            }
            doc.write('</div>');

            // Score
            doc.write('<div class="score-area"><div class="score-label">比分</div><div class="score-boxes"><div class="score-box"></div><span class="score-colon">:</span><div class="score-box"></div></div></div>');

            // Right player box
            doc.write('<div class="player-box">');
            m.p2.forEach(name => {
                doc.write('<div class="slot-row"><div class="slot-name">' + escapeXml(name) + '</div><div class="slot-left"></div></div>');
            });
            doc.write('</div>');
            doc.write('</div>');

            // Footer
            doc.write('<div class="sheet-footer">');
            doc.write('<div class="f-item">勝方 <span class="f-line">&nbsp;</span></div>');
            doc.write('<div class="f-item">裁判 <span class="f-line">&nbsp;</span></div>');
            doc.write('<div class="f-item">裁判長 <span class="f-line">&nbsp;</span></div>');
            doc.write('</div>');
            doc.write('</div>');
        }
        doc.write('</div>');
    }

    // PDF download script
    doc.write('<scr' + 'ipt>');
    doc.write('function downloadPDF() {');
    doc.write('  if (typeof jspdf === "undefined") { alert("PDF 元件載入中，請稍後再試"); return; }');
    doc.write('  var pages = document.querySelectorAll(".sheet-page");');
    doc.write('  var pdf = new jspdf.jsPDF({orientation:"portrait",unit:"mm",format:"a4",compress:true});');
    doc.write('  var loaded = 0;');
    doc.write('  var imgs = [];');
    doc.write('  pages.forEach(function(page, idx) {');
    doc.write('    html2canvas(page, { scale: 2, useCORS: true, backgroundColor: "#fff" }).then(function(canvas) {');
    doc.write('      imgs[idx] = canvas.toDataURL("image/jpeg", 0.8);');
    doc.write('      loaded++;');
    doc.write('      if (loaded === pages.length) buildPdf(imgs);');
    doc.write('    });');
    doc.write('  });');
    doc.write('  function buildPdf(imgs) {');
    doc.write('    for (var i = 0; i < imgs.length; i++) {');
    doc.write('      if (i > 0) pdf.addPage();');
    doc.write('      pdf.addImage(imgs[i], "JPEG", 0, 0, 210, 297, undefined, "FAST");');
    doc.write('    }');
    doc.write('    pdf.save("出賽單.pdf");');
    doc.write('  }');
    doc.write('}');
    doc.write('</scr' + 'ipt>');
    doc.write('</body></html>');
    doc.close();
    showToast('已產生 ' + matches.length + ' 張出賽單', 'success');
}

// ============================================================
// Save / Load tournament file (.xlsx)
// ============================================================
async function saveToExcel() {
    if (Object.keys(state.activeGroups).length === 0 && Object.keys(state.setupPool).length === 0) {
        showToast('尚無資料可存檔', 'error'); return;
    }
    try { await loadLib('xlsx'); } catch(err) { showToast(err.message, 'error'); return; }

    const serialized = serializeState();
    const scores = serialized.scores;

    const wb = XLSX.utils.book_new();

    // _state sheet: JSON data for restore
    const stateData = JSON.stringify(serialized);
    const stateSheet = XLSX.utils.aoa_to_sheet([
        ['__BADMINTON_SAVE_V1__'],
        [stateData]
    ]);
    XLSX.utils.book_append_sheet(wb, stateSheet, '_state');

    // Human-readable sheets per category
    for (const cat in state.activeGroups) {
        const rows = [];
        rows.push([cat]);
        rows.push([]);
        state.activeGroups[cat].forEach(group => {
            rows.push([group.name + ' 組（' + group.members.join('、') + '）']);
            rows.push(['場次', '選手1', '比分1', 'VS', '比分2', '選手2', '備註']);
            group.matches.forEach(m => {
                const sc = scores[m.matchId] || ['', '', '', ''];
                const typeLabel = { [FF_TYPES.INJURY]: '受傷棄權', [FF_TYPES.VOLUNTARY]: '主動棄權' };
                let note = '';
                if (sc[2]) note += group.members[m.p1] + ' ' + (typeLabel[sc[2]] || '棄權');
                if (sc[3]) note += (note ? '、' : '') + group.members[m.p2] + ' ' + (typeLabel[sc[3]] || '棄權');
                const d1 = sc[2] === FF_TYPES.VOLUNTARY ? '棄' : (sc[2] === FF_TYPES.INJURY ? sc[0] + '(傷)' : sc[0]);
                const d2 = sc[3] === FF_TYPES.VOLUNTARY ? '棄' : (sc[3] === FF_TYPES.INJURY ? sc[1] + '(傷)' : sc[1]);
                rows.push([m.matchNo, group.members[m.p1], d1, 'VS', d2, group.members[m.p2], note]);
            });
            rows.push([]);
        });
        const ws = XLSX.utils.aoa_to_sheet(rows);
        ws['!cols'] = [{ wch: 6 }, { wch: 18 }, { wch: 6 }, { wch: 4 }, { wch: 6 }, { wch: 18 }, { wch: 20 }];
        XLSX.utils.book_append_sheet(wb, ws, cat.substring(0, 31));
    }

    const now = new Date();
    const ts = now.getFullYear() + String(now.getMonth() + 1).padStart(2, '0') + String(now.getDate()).padStart(2, '0') +
               '_' + String(now.getHours()).padStart(2, '0') + String(now.getMinutes()).padStart(2, '0');
    XLSX.writeFile(wb, '羽球賽務存檔_' + ts + '.xlsx');
    showToast('存檔成功', 'success');
}

async function loadFromExcel(event) {
    const file = event.target.files[0];
    if (!file) return;
    try { await loadLib('xlsx'); } catch(err) { showToast(err.message, 'error'); return; }
    if (Object.keys(state.activeGroups).length > 0 || Object.keys(state.setupPool).length > 0) {
        if (!await customConfirm('載入存檔將覆蓋目前所有資料，確定要繼續嗎？')) { event.target.value = ''; return; }
    }
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const wb = XLSX.read(e.target.result, { type: 'array' });
            // Check for _state sheet
            if (!wb.SheetNames.includes('_state')) {
                showToast('此檔案非賽務存檔（缺少 _state）', 'error');
                return;
            }
            const data = XLSX.utils.sheet_to_json(wb.Sheets['_state'], { header: 1 });
            if (!data[0] || data[0][0] !== '__BADMINTON_SAVE_V1__') {
                showToast('存檔格式不正確', 'error');
                return;
            }
            const saved = JSON.parse(data[1][0]);

            // Restore state (unconditional to clear stale values)
            state.setupPool = saved.setupPool || {};
            state.activeGroups = saved.activeGroups || {};
            state.manualQualify = saved.manualQualify || {};
            migrateFinalQualifiers(saved);
            state.prelimBronze = saved.prelimBronze || {};
            state.prelimResults = saved.prelimResults || {};
            state.eventTitle = saved.eventTitle || '';
            const h1 = document.getElementById('eventTitle');
            if (h1) h1.textContent = state.eventTitle || '羽球賽務系統';
            document.title = (state.eventTitle || '羽球賽務系統') + ' ' + APP_VERSION;
            state.selectedPoolItem = null;
            state.editingKey = null;
            undoStack.length = 0;
            redoStack.length = 0;

            // Rebuild UI
            refreshPoolList();
            if (Object.keys(state.activeGroups).length > 0) {
                rebuildScoringUI(saved.scores || {});
            }
            if (hasFinalQualifiers()) {
                renderFinalsTabBar();
                renderFinalsList();
            }
            saveState();
            showToast('存檔載入成功', 'success');
        } catch (err) {
            showToast('載入失敗: ' + err.message, 'error');
        }
    };
    reader.readAsArrayBuffer(file);
    event.target.value = '';
}

// ============================================================
// JSON Backup / Restore (不需網路，不依賴 xlsx)
// ============================================================
function exportJSON() {
    if (Object.keys(state.activeGroups).length === 0 && Object.keys(state.setupPool).length === 0) {
        showToast('尚無資料可備份', 'error'); return;
    }
    const data = JSON.stringify(serializeState(), null, 2);
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const now = new Date();
    const ts = now.getFullYear() + String(now.getMonth() + 1).padStart(2, '0') + String(now.getDate()).padStart(2, '0') +
               '_' + String(now.getHours()).padStart(2, '0') + String(now.getMinutes()).padStart(2, '0');
    a.href = url;
    a.download = '羽球賽務備份_' + ts + '.json';
    a.click();
    URL.revokeObjectURL(url);
    showToast('JSON 備份已下載', 'success');
}

async function importJSON(event) {
    const file = event.target.files[0];
    if (!file) return;
    if (Object.keys(state.activeGroups).length > 0 || Object.keys(state.setupPool).length > 0) {
        if (!await customConfirm('載入備份將覆蓋目前所有資料，確定要繼續嗎？')) {
            event.target.value = ''; return;
        }
    }
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const saved = JSON.parse(e.target.result);
            if (!saved.setupPool && !saved.activeGroups) {
                showToast('此檔案非賽務備份（格式不正確）', 'error'); return;
            }
            pushUndo();
            state.setupPool = saved.setupPool || {};
            state.activeGroups = saved.activeGroups || {};
            state.manualQualify = saved.manualQualify || {};
            migrateFinalQualifiers(saved);
            state.prelimBronze = saved.prelimBronze || {};
            state.prelimResults = saved.prelimResults || {};
            state.eventTitle = saved.eventTitle || '';
            undoStack.length = 0;
            redoStack.length = 0;
            refreshPoolList();
            if (Object.keys(state.activeGroups).length > 0) {
                rebuildScoringUI(saved.scores || {});
            }
            if (hasFinalQualifiers()) {
                renderFinalsTabBar();
                const cats = getFinalsCategories();
                if (cats.length > 0) {
                    state.activeCategory = cats[0];
                    switchFinalsCategory(cats[0]);
                }
            }
            const h1 = document.getElementById('eventTitle');
            if (h1) h1.textContent = state.eventTitle || '羽球賽務系統';
            document.title = (state.eventTitle || '羽球賽務系統') + ' ' + APP_VERSION;
            saveState();
            showToast('JSON 備份載入成功', 'success');
        } catch (err) {
            showToast('載入失敗: ' + err.message, 'error');
        }
    };
    reader.readAsText(file);
    event.target.value = '';
}

// ============================================================
// CSV export (比賽明細)
// ============================================================
function exportCSV() {
    if (Object.keys(state.activeGroups).length === 0) { showToast('尚無賽事資料', 'error'); return; }
    const BOM = '\uFEFF';
    const rows = [['類別', '組別', '場次', '選手1', '分數1', '分數2', '選手2', '勝者', '備註']];

    for (const cat in state.activeGroups) {
        state.activeGroups[cat].forEach(g => {
            let matchNo = 0;
            g.matches.forEach(m => {
                matchNo++;
                const s1El = document.getElementById('s1_' + m.matchId);
                const s2El = document.getElementById('s2_' + m.matchId);
                const v1 = s1El ? s1El.value : '';
                const v2 = s2El ? s2El.value : '';
                const p1 = g.members[m.p1] || '';
                const p2 = g.members[m.p2] || '';
                let winner = '';
                if (v1 !== '' && v2 !== '' && !isNaN(v1) && !isNaN(v2)) {
                    winner = parseInt(v1) > parseInt(v2) ? p1 : (parseInt(v2) > parseInt(v1) ? p2 : '平手');
                }
                // Check forfeit
                const ff1 = document.getElementById('ff1_' + m.matchId);
                const ff2 = document.getElementById('ff2_' + m.matchId);
                let note = '';
                if (ff1 && ff1.getAttribute('data-ff')) note += p1 + (ff1.getAttribute('data-ff') === 'injury' ? '(傷)' : '(棄)');
                if (ff2 && ff2.getAttribute('data-ff')) note += (note ? ' ' : '') + p2 + (ff2.getAttribute('data-ff') === 'injury' ? '(傷)' : '(棄)');
                rows.push([cat, g.name + '組', matchNo, p1, v1, v2, p2, winner, note]);
            });
        });
    }

    // Add finals matches
    const finalsCats = typeof getFinalsCategories === 'function' ? getFinalsCategories() : [];
    finalsCats.forEach(cat => {
        const matches = state.bracketMatches[cat] || [];
        const rounds = getBracketRoundCount(matches);
        let matchNo = 0;
        matches.forEach(m => {
            if (!m.p1 || !m.p2 || m.p1 === '—BYE—' || m.p2 === '—BYE—' || m.p1 === '—TBD—' || m.p2 === '—TBD—') return;
            matchNo++;
            const roundName = m.isThirdPlace ? '季軍賽' : getRoundName(m.round, rounds);
            rows.push([cat, '決賽' + roundName, matchNo, m.p1, m.s1 || '', m.s2 || '', m.p2, m.winner || '', '']);
        });
    });

    const csvContent = BOM + rows.map(r => r.map(c => '"' + String(c).replace(/"/g, '""') + '"').join(',')).join('\n');
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    const now = new Date();
    const ts = now.getFullYear() + String(now.getMonth() + 1).padStart(2, '0') + String(now.getDate()).padStart(2, '0');
    a.href = url;
    a.download = (state.eventTitle || '羽球比賽') + '_成績明細_' + ts + '.csv';
    a.click();
    URL.revokeObjectURL(url);
    showToast('CSV 已下載', 'success');
}

// ============================================================
// Excel export (成績報表)
// ============================================================
async function generateExcel() {
    if (Object.keys(state.activeGroups).length === 0) { showToast('尚無賽事資料', 'error'); return; }
    try { await loadLib('xlsx'); } catch(err) { showToast(err.message, 'error'); return; }

    const wb = XLSX.utils.book_new();

    for (const cat in state.activeGroups) {
        const rows = [];
        if (state.eventTitle) rows.push([getEventTitle()]);
        rows.push([`賽制: ${cat}`]);
        rows.push([]);

        state.activeGroups[cat].forEach(group => {
            const n = group.members.length;

            // --- 多角對戰圖 (Round-Robin Matrix) ---
            rows.push([`${group.name} 組 — 多角對戰圖`]);

            // Build score matrix: scoreMatrix[i][j] = "v1:v2" or "棄權" from i's perspective
            const scoreMatrix = Array.from({ length: n }, () => Array(n).fill(''));
            group.matches.forEach(m => {
                const f1 = getFF(m.matchId, 1);
                const f2 = getFF(m.matchId, 2);
                const { v1, v2 } = getMatchScores(m.matchId);
                if (f1 || f2) {
                    // Injury: show score + (傷), Voluntary: show 棄
                    if (f1 === FF_TYPES.INJURY) {
                        scoreMatrix[m.p1][m.p2] = (v1 && v2 ? v1 + ':' + v2 : '') + '(傷)';
                        scoreMatrix[m.p2][m.p1] = (v1 && v2 ? v2 + ':' + v1 : '') + ' W';
                    } else if (f1 === FF_TYPES.VOLUNTARY) {
                        scoreMatrix[m.p1][m.p2] = '棄';
                        scoreMatrix[m.p2][m.p1] = 'W';
                    }
                    if (f2 === FF_TYPES.INJURY) {
                        scoreMatrix[m.p2][m.p1] = (v1 && v2 ? v2 + ':' + v1 : '') + '(傷)';
                        scoreMatrix[m.p1][m.p2] = (v1 && v2 ? v1 + ':' + v2 : '') + ' W';
                    } else if (f2 === FF_TYPES.VOLUNTARY) {
                        scoreMatrix[m.p2][m.p1] = '棄';
                        scoreMatrix[m.p1][m.p2] = 'W';
                    }
                    return;
                }
                if (v1 !== '' && v2 !== '') {
                    scoreMatrix[m.p1][m.p2] = `${v1}:${v2}`;
                    scoreMatrix[m.p2][m.p1] = `${v2}:${v1}`;
                }
            });

            // Reuse getScores() for stats
            const { scores } = getScores(cat, group);
            const stats = group.members.map((_, i) => ({
                w: scores[i].wins, l: scores[i].losses, ff: scores[i].forfeits || 0, pf: scores[i].pf, pa: scores[i].pa
            }));

            // Header row
            const header = [`${group.name}組`];
            group.members.forEach(m => header.push(m));
            header.push('勝', '負', '棄權', '淨分', '排名');
            rows.push(header);

            // Rank players
            const ranked = group.members.map((_, i) => i).sort((a, b) => {
                if (stats[b].w !== stats[a].w) return stats[b].w - stats[a].w;
                return (stats[b].pf - stats[b].pa) - (stats[a].pf - stats[a].pa);
            });
            const rankMap = {};
            ranked.forEach((idx, r) => rankMap[idx] = r + 1);

            // Data rows
            group.members.forEach((name, i) => {
                const row = [name];
                for (let j = 0; j < n; j++) {
                    if (i === j) row.push('\\');
                    else row.push(scoreMatrix[i][j] || '-');
                }
                row.push(stats[i].w, stats[i].l, stats[i].ff, stats[i].pf - stats[i].pa, rankMap[i]);
                rows.push(row);
            });

            rows.push([]);

            // --- 場次明細 ---
            rows.push(['場次明細']);
            rows.push(['場次', '選手1', '比分', '', '選手2', '', '備註']);
            group.matches.forEach(m => {
                const f1 = getFF(m.matchId, 1);
                const f2 = getFF(m.matchId, 2);
                const { v1, v2 } = getMatchScores(m.matchId);
                let note = '';
                const typeLabel = { [FF_TYPES.INJURY]: '受傷棄權', [FF_TYPES.VOLUNTARY]: '主動棄權' };
                if (f1) note += group.members[m.p1] + ' ' + typeLabel[f1];
                if (f2) note += (note ? '、' : '') + group.members[m.p2] + ' ' + typeLabel[f2];
                const d1 = f1 === FF_TYPES.VOLUNTARY ? '棄' : (f1 === FF_TYPES.INJURY ? v1 + '(傷)' : v1);
                const d2 = f2 === FF_TYPES.VOLUNTARY ? '棄' : (f2 === FF_TYPES.INJURY ? v2 + '(傷)' : v2);
                rows.push([m.matchNo, group.members[m.p1], d1, 'VS', d2, group.members[m.p2], note]);
            });

            rows.push([]); rows.push([]);
        });

        const ws = XLSX.utils.aoa_to_sheet(rows);

        // Style: set column widths
        const maxMembers = Math.max(...state.activeGroups[cat].map(g => g.members.length));
        const cols = [{ wch: 16 }];
        for (let i = 0; i < maxMembers; i++) cols.push({ wch: 14 });
        cols.push({ wch: 5 }, { wch: 5 }, { wch: 6 }, { wch: 6 });
        ws['!cols'] = cols;

        XLSX.utils.book_append_sheet(wb, ws, cat.substring(0, 31));
    }

    XLSX.writeFile(wb, '羽球預賽成績.xlsx');
    showToast('Excel 已下載', 'success');
}

async function exportFinalsExcel() {
    if (!hasFinalQualifiers()) { showToast('無晉級者', 'error'); return; }
    try { await loadLib('xlsx'); } catch(err) { showToast(err.message, 'error'); return; }
    const wb = XLSX.utils.book_new();
    getFinalsCategories().forEach(cat => {
        const qualifiers = state.finalQualifiers[cat];
        const rows = [[cat + ' 決賽名單'], [], ['序號', '來源', '選手']];
        qualifiers.forEach((q, i) => rows.push([i + 1, q.label, q.name]));
        const result = getBracketResultsForCategory(cat);
        if (result) {
            rows.push([]);
            rows.push(['比賽結果']);
            rows.push(['冠軍', result.champion]);
            rows.push(['亞軍', result.runnerUp]);
            if (result.bronzes.length > 0) rows.push(['季軍', result.bronzes.join('、')]);
            if (result.fourth) rows.push(['殿軍', result.fourth]);
        }
        const ws = XLSX.utils.aoa_to_sheet(rows);
        ws['!cols'] = [{ wch: 8 }, { wch: 20 }, { wch: 20 }];
        XLSX.utils.book_append_sheet(wb, ws, cat.substring(0, 31));
    });
    XLSX.writeFile(wb, '羽球決賽名單.xlsx');
    showToast('決賽 Excel 已下載', 'success');
}

// ============================================================
// Chart View — 多角對戰圖 (SVG)
// ============================================================
function openChartView() {
    if (Object.keys(state.activeGroups).length === 0) { showToast('尚無賽事資料', 'error'); return; }

    // Collect all groups across all categories
    const allGroups = [];
    for (const cat in state.activeGroups) {
        state.activeGroups[cat].forEach(group => {
            allGroups.push({ cat, group });
        });
    }

    // Layout: 2 per row, max 3 rows per page (matching screenshot)
    const cols = 2;
    const maxRowsPerPage = 3;
    const groupW = 300, groupH = 300, gapX = 60, gapY = 10;
    const pageW = cols * groupW + gapX * 3;
    const titleH = 80;

    // Per-category pages: group by category, then paginate
    const catPages = []; // [{cat, titleInfo, groups: [group,...]}]
    for (const cat in state.activeGroups) {
        const groups = state.activeGroups[cat];
        const totalGroups = groups.length;
        const totalInCat = groups.reduce((s, g) => s + g.members.length, 0);
        const nQualify = groups.reduce((s, g) => s + getQualifyCount(g.members.length, totalInCat), 0);
        const titleInfo = '賽制: ' + cat + '\n組數: ' + totalGroups + '\n晉級: ' + nQualify;
        // Paginate within category
        for (let i = 0; i < groups.length; i += cols * maxRowsPerPage) {
            catPages.push({
                cat,
                titleInfo,
                groups: groups.slice(i, i + cols * maxRowsPerPage)
            });
        }
    }

    // Open print window
    const win = openPrintWindow();
    if (!win) return;
    const doc = win.document;
    doc.open();
    doc.write('<!DOCTYPE html><html><head><meta charset="UTF-8"><title>' + escapeXml(getEventTitle()) + ' 對戰圖</title>');
    doc.write('<scr' + 'ipt src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></scr' + 'ipt>');
    doc.write('<style>');
    doc.write('@media print { body { margin: 0; } .no-print { display: none; } .page-break { page-break-after: always; } }');
    doc.write('body { font-family: "Microsoft JhengHei", sans-serif; background: #fff; margin: 20px; }');
    doc.write('.no-print { text-align: center; margin-bottom: 16px; }');
    doc.write('.no-print button, .no-print select { padding: 8px 16px; font-size: 14px; border-radius: 6px; cursor: pointer; margin: 0 4px; font-weight: 600; vertical-align: middle; }');
    doc.write('.no-print select { border: 1px solid #ccc; cursor: pointer; }');
    doc.write('.btn-print { background: #1a73e8; color: #fff; border: none; }');
    doc.write('.btn-download { background: #34a853; color: #fff; border: none; }');
    doc.write('.btn-pdf { background: #ea4335; color: #fff; border: none; }');
    doc.write('svg { display: block; margin: 0 auto 20px; max-width: 100%; }');
    doc.write('</style>');
    doc.write('<style id="orientStyle">@media print { @page { margin: 8mm; size: portrait; } svg { max-height: 275mm; width: auto; height: auto; } }</style>');
    doc.write('</head><body>');
    doc.write('<div class="no-print">');
    doc.write('<select id="orientSelect" onchange="updateOrient()"><option value="portrait">直向</option><option value="landscape">橫向</option></select>');
    doc.write('<button class="btn-print" onclick="window.print()">列印</button>');
    doc.write('<button class="btn-pdf" onclick="downloadPDF()">下載 PDF</button>');
    doc.write('<button class="btn-download" onclick="downloadSVG()">下載 SVG</button>');
    doc.write('</div>');

    const allSvgIds = [];

    // Render each page
    catPages.forEach((page, pi) => {
        const rowsCount = Math.ceil(page.groups.length / cols);
        const pageH = titleH + rowsCount * (groupH + gapY) + 20;
        const svgId = 'chartSvg_' + pi;
        allSvgIds.push(svgId);

        let svg = '';
        // Title block: 賽制 / 組數 / 晉級 (left-top corner only)
        const lines = page.titleInfo.split('\n');
        svg += '<text x="15" y="20" font-size="14" font-weight="bold" font-family="Microsoft JhengHei, sans-serif" fill="#000">' + escapeXml(lines[0]) + '</text>';
        svg += '<text x="15" y="40" font-size="14" font-weight="bold" font-family="Microsoft JhengHei, sans-serif" fill="#000">' + escapeXml(lines[1]) + '</text>';
        svg += '<text x="15" y="60" font-size="14" font-weight="bold" font-family="Microsoft JhengHei, sans-serif" fill="#000">' + escapeXml(lines[2]) + '</text>';

        let gx = gapX, gy = titleH;
        let colIdx = 0;

        page.groups.forEach((group) => {
            const n = group.members.length;
            if (n === 3) svg += drawTriangleGroup(gx, gy, groupW, groupH, page.cat, group);
            else if (n === 4) svg += drawSquareGroup(gx, gy, groupW, groupH, page.cat, group);
            else if (n === 2) svg += drawLineGroup(gx, gy, groupW, groupH, page.cat, group);

            colIdx++;
            if (colIdx >= cols) {
                colIdx = 0;
                gx = gapX;
                gy += groupH + gapY;
            } else {
                gx += groupW + gapX;
            }
        });

        doc.write('<div class="page-break">');
        doc.write('<svg id="' + svgId + '" xmlns="http://www.w3.org/2000/svg" width="' + pageW + '" height="' + pageH + '" viewBox="0 0 ' + pageW + ' ' + pageH + '">');
        doc.write('<rect width="100%" height="100%" fill="white"/>');
        doc.write(svg);
        doc.write('</svg></div>');
    });

    // Write download script into child window (using split tags to avoid breaking parent)
    var idsJson = JSON.stringify(allSvgIds);
    doc.write('<scr' + 'ipt>');
    doc.write('var svgIds = ' + idsJson + ';');
    doc.write('function downloadSVG() {');
    doc.write('  var c = "";');
    doc.write('  for (var i = 0; i < svgIds.length; i++) c += document.getElementById(svgIds[i]).outerHTML + "\\n";');
    doc.write('  var b = new Blob([c], {type:"image/svg+xml"});');
    doc.write('  var a = document.createElement("a");');
    doc.write('  a.href = URL.createObjectURL(b); a.download = "對戰圖.svg"; a.click();');
    doc.write('}');
    doc.write('function updateOrient(){var o=document.getElementById("orientSelect").value;var h=o==="landscape"?"190mm":"275mm";document.getElementById("orientStyle").textContent="@media print{@page{margin:8mm;size:"+o+";}svg{max-height:"+h+";width:auto;height:auto;}}";}');
    doc.write('function getOrient(){return document.getElementById("orientSelect").value;}');
    doc.write('function downloadPDF() {');
    doc.write('  if (typeof jspdf === "undefined") { alert("PDF 元件載入中，請稍後再試"); return; }');
    doc.write('  var orient = getOrient();');
    doc.write('  var imgs = [], loaded = 0, total = svgIds.length;');
    doc.write('  svgIds.forEach(function(id, idx) {');
    doc.write('    var el = document.getElementById(id);');
    doc.write('    var data = new XMLSerializer().serializeToString(el);');
    doc.write('    var blob = new Blob([data], {type:"image/svg+xml;charset=utf-8"});');
    doc.write('    var url = URL.createObjectURL(blob);');
    doc.write('    var img = new Image();');
    doc.write('    img.onload = function() {');
    doc.write('      var cv = document.createElement("canvas");');
    doc.write('      var sc = 1.5;');
    doc.write('      cv.width = img.width * sc; cv.height = img.height * sc;');
    doc.write('      var ctx = cv.getContext("2d");');
    doc.write('      ctx.fillStyle = "#fff"; ctx.fillRect(0,0,cv.width,cv.height);');
    doc.write('      ctx.scale(sc,sc); ctx.drawImage(img,0,0);');
    doc.write('      imgs[idx] = {d:cv.toDataURL("image/jpeg",0.75), w:img.width, h:img.height};');
    doc.write('      URL.revokeObjectURL(url);');
    doc.write('      loaded++;');
    doc.write('      if (loaded === total) makePDF(imgs);');
    doc.write('    };');
    doc.write('    img.src = url;');
    doc.write('  });');
    doc.write('  function makePDF(imgs) {');
    doc.write('    var pw=orient==="landscape"?297:210, ph=orient==="landscape"?210:297, m=8, uw=pw-m*2, uh=ph-m*2;');
    doc.write('    var pdf = new jspdf.jsPDF({orientation:orient,unit:"mm",format:"a4",compress:true});');
    doc.write('    imgs.forEach(function(im,i) {');
    doc.write('      if(i>0) pdf.addPage("a4",orient);');
    doc.write('      var r = Math.min(uw/im.w, uh/im.h);');
    doc.write('      pdf.addImage(im.d,"JPEG",m+(uw-im.w*r)/2,m,im.w*r,im.h*r,undefined,"FAST");');
    doc.write('    });');
    doc.write('    pdf.save("對戰圖.pdf");');
    doc.write('  }');
    doc.write('}');
    doc.write('</scr' + 'ipt>');
    doc.write('</body></html>');
    doc.close();
}

function escapeXml(s) {
    return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
}

function escapeJsInAttr(s) {
    return s.replace(/\\/g, '\\\\').replace(/'/g, "\\'").replace(/</g, '\\x3c').replace(/>/g, '\\x3e');
}

function openPrintWindow() {
    const win = window.open('', '_blank');
    if (!win) { showToast('無法開啟列印視窗，請允許彈出視窗', 'error'); return null; }
    return win;
}

// Match number label: *N format
function matchNumLabel(x, y, num, fontSize) {
    fontSize = fontSize || 12;
    return `<text x="${x}" y="${y + 4}" text-anchor="middle" font-size="${fontSize}" font-weight="bold" font-family="Microsoft JhengHei, sans-serif" fill="#333">*${num}</text>`;
}

// Player label — two lines: school on top, name below
// cat: category name to strip from the beginning if present
function playerLabel(x, y, text, anchor, cat) {
    anchor = anchor || 'middle';
    // Strip category prefix if present (e.g. "四女單 仁愛國小 陳怡昊" → "仁愛國小 陳怡昊")
    let cleaned = text.trim();
    if (cat && cleaned.startsWith(cat)) {
        cleaned = cleaned.substring(cat.length).trim();
    }
    const parts = cleaned.split(/\s+/);
    let school, name;
    if (parts.length >= 2) {
        school = parts[0];
        name = parts.slice(1).join(' ');
    } else {
        school = cleaned;
        name = '';
    }
    let s = `<text x="${x}" y="${y}" text-anchor="${anchor}" font-size="11" font-family="Microsoft JhengHei, sans-serif" fill="#555">${escapeXml(school)}</text>`;
    if (name) {
        s += `<text x="${x}" y="${y + 15}" text-anchor="${anchor}" font-size="11" font-family="Microsoft JhengHei, sans-serif" fill="#555">${escapeXml(name)}</text>`;
    }
    return s;
}

// ---- Triangle (3 players) ----
function drawTriangleGroup(ox, oy, w, h, cat, group) {
    let s = '';
    const members = group.members;
    const gName = group.name;

    // Triangle with room for 2-line labels above top and below bottom
    const topX = ox + w / 2, topY = oy + 80;
    const blX = ox + 40, blY = oy + h - 60;
    const brX = ox + w - 40, brY = oy + h - 60;

    // Lines
    s += `<line x1="${topX}" y1="${topY}" x2="${blX}" y2="${blY}" stroke="#333" stroke-width="1.5"/>`;
    s += `<line x1="${topX}" y1="${topY}" x2="${brX}" y2="${brY}" stroke="#333" stroke-width="1.5"/>`;
    s += `<line x1="${blX}" y1="${blY}" x2="${brX}" y2="${brY}" stroke="#333" stroke-width="1.5"/>`;

    // Center letter (large, light gray)
    const cx = ox + w / 2, cy = (topY + blY) / 2 + 15;
    s += `<text x="${cx}" y="${cy}" text-anchor="middle" font-size="60" font-weight="bold" fill="#ddd" font-family="Arial, sans-serif">${gName}</text>`;

    // Match numbers on edges: *N format
    const matchNums = group.matches.map(m => m.matchNo);
    // Left edge midpoint (shift left)
    const m0x = (topX + blX) / 2 - 16, m0y = (topY + blY) / 2;
    // Right edge midpoint (shift right)
    const m1x = (topX + brX) / 2 + 16, m1y = (topY + brY) / 2;
    // Bottom edge midpoint (shift down)
    const m2x = (blX + brX) / 2, m2y = blY + 18;

    if (matchNums[0] !== undefined) s += matchNumLabel(m0x, m0y, matchNums[0]);
    if (matchNums[1] !== undefined) s += matchNumLabel(m1x, m1y, matchNums[1]);
    if (matchNums[2] !== undefined) s += matchNumLabel(m2x, m2y, matchNums[2]);

    // Player labels (2-line: school + name), strip category prefix
    s += playerLabel(topX, topY - 30, members[0], 'middle', cat);
    s += playerLabel(blX - 10, blY + 22, members[1], 'start', cat);
    s += playerLabel(brX + 10, brY + 22, members[2], 'end', cat);

    return s;
}

// ---- Square + X (4 players) ----
function drawSquareGroup(ox, oy, w, h, cat, group) {
    let s = '';
    const members = group.members;
    const gName = group.name;

    const tlX = ox + 50, tlY = oy + 70;
    const trX = ox + w - 50, trY = oy + 70;
    const blX = ox + 50, blY = oy + h - 60;
    const brX = ox + w - 50, brY = oy + h - 60;

    // Square edges
    s += `<line x1="${tlX}" y1="${tlY}" x2="${trX}" y2="${trY}" stroke="#333" stroke-width="1.5"/>`;
    s += `<line x1="${trX}" y1="${trY}" x2="${brX}" y2="${brY}" stroke="#333" stroke-width="1.5"/>`;
    s += `<line x1="${brX}" y1="${brY}" x2="${blX}" y2="${blY}" stroke="#333" stroke-width="1.5"/>`;
    s += `<line x1="${blX}" y1="${blY}" x2="${tlX}" y2="${tlY}" stroke="#333" stroke-width="1.5"/>`;
    // Diagonals
    s += `<line x1="${tlX}" y1="${tlY}" x2="${brX}" y2="${brY}" stroke="#333" stroke-width="1.5"/>`;
    s += `<line x1="${trX}" y1="${trY}" x2="${blX}" y2="${blY}" stroke="#333" stroke-width="1.5"/>`;

    // Center letter
    const cx = ox + w / 2, cy = (tlY + blY) / 2 + 15;
    s += `<text x="${cx}" y="${cy}" text-anchor="middle" font-size="60" font-weight="bold" fill="#ddd" font-family="Arial, sans-serif">${gName}</text>`;

    // Match numbers — order: (0,1) top, (2,3) bottom, (0,2) left, (1,3) right, (0,3) diag-\, (1,2) diag-/
    const matchNums = group.matches.map(m => m.matchNo);
    const positions = [
        [(tlX + trX) / 2, tlY - 14],                                       // top edge (0,1)
        [(blX + brX) / 2, blY + 18],                                       // bottom edge (2,3)
        [tlX - 20, (tlY + blY) / 2],                                       // left edge (0,2)
        [trX + 20, (trY + brY) / 2],                                       // right edge (1,3)
        [tlX + (brX - tlX) * 0.3, tlY + (brY - tlY) * 0.28],              // diag \ (0,3) upper-left
        [trX + (blX - trX) * 0.3, trY + (blY - trY) * 0.28],              // diag / (1,2) upper-right
    ];
    matchNums.forEach((num, i) => {
        if (i < positions.length) s += matchNumLabel(positions[i][0], positions[i][1], num);
    });

    // Player labels (2-line), strip category prefix
    s += playerLabel(tlX - 10, tlY - 25, members[0], 'start', cat);
    s += playerLabel(trX + 10, trY - 25, members[1], 'end', cat);
    s += playerLabel(blX - 10, blY + 22, members[2], 'start', cat);
    s += playerLabel(brX + 10, brY + 22, members[3], 'end', cat);

    return s;
}

// ---- Line (2 players) ----
function drawLineGroup(ox, oy, w, h, cat, group) {
    let s = '';
    const members = group.members;
    const gName = group.name;
    const cy = oy + h / 2;
    const lx = ox + 60, rx = ox + w - 60;

    s += `<line x1="${lx}" y1="${cy}" x2="${rx}" y2="${cy}" stroke="#333" stroke-width="1.5"/>`;

    // Center letter
    const cx = ox + w / 2;
    s += `<text x="${cx}" y="${cy - 20}" text-anchor="middle" font-size="60" font-weight="bold" fill="#ddd" font-family="Arial, sans-serif">${gName}</text>`;

    // Match number
    if (group.matches.length > 0) {
        s += matchNumLabel(cx, cy - 8, group.matches[0].matchNo);
    }

    // Labels (2-line), strip category prefix
    s += playerLabel(lx - 10, cy + 22, members[0], 'start', cat);
    s += playerLabel(rx + 10, cy + 22, members[1], 'end', cat);

    return s;
}

// ---- Single Elimination Bracket SVG ----
function buildBracketSVG(qualifiers, totalWidth, isDoubles) {
    const realP = qualifiers.map(q => q.name);
    const n = realP.length;
    const size = Math.pow(2, Math.ceil(Math.log2(n)));
    const seedOrdSvg = bracketSeedOrder(size);
    const players = new Array(size);
    for (let pos = 0; pos < size; pos++) players[pos] = seedOrdSvg[pos] < n ? realP[seedOrdSvg[pos]] : null;

    const rounds = Math.log2(size);
    // Dynamic matchH: shrink for large brackets so it fits A4 page
    // Doubles need taller slots to show 2 player names per slot
    const baseMatchH = Math.max(26, Math.min(50, Math.floor(1100 / size)));
    const matchH = isDoubles ? Math.max(44, Math.floor(baseMatchH * 1.6)) : baseMatchH;
    const slotH = Math.max(12, Math.floor(matchH * 0.44));
    const fontSize = matchH >= 40 ? 11 : matchH >= 30 ? 10 : 9;
    const roundW = 180, gapRound = 60;
    const startX = 40;
    const baseH = size * matchH;
    const totalH = baseH + 80;
    const svgW = Math.max(totalWidth, rounds * (roundW + gapRound) + 100);

    let s = '';
    let globalMatchNo = 1;

    // Pre-calculate all global match numbers from group stage
    for (const cat in state.activeGroups) {
        state.activeGroups[cat].forEach(g => {
            g.matches.forEach(m => {
                if (m.matchNo >= globalMatchNo) globalMatchNo = m.matchNo + 1;
            });
        });
    }

    // Build bracket data
    let currentSlots = [];
    for (let i = 0; i < size; i += 2) {
        currentSlots.push({ p1: players[i], p2: players[i + 1] });
    }

    const roundLabels = [];
    for (let r = 0; r < rounds; r++) {
        if (r === rounds - 1) roundLabels.push('決賽');
        else if (r === rounds - 2) roundLabels.push('準決賽');
        else roundLabels.push(`第${r + 1}輪`);
    }

    // Separator line
    s += `<line x1="20" y1="10" x2="${svgW - 20}" y2="10" stroke="#ccc" stroke-width="0.5" stroke-dasharray="4"/>`;
    s += `<text x="${svgW / 2}" y="30" text-anchor="middle" font-size="14" font-weight="bold" font-family="Microsoft JhengHei, sans-serif">決賽 — 單淘汰賽</text>`;

    for (let r = 0; r < rounds; r++) {
        const nMatches = currentSlots.length;
        const spacing = baseH / nMatches;
        const rx = startX + r * (roundW + gapRound);

        // Round label
        s += `<text x="${rx + roundW / 2}" y="50" text-anchor="middle" font-size="11" fill="#888" font-family="Microsoft JhengHei, sans-serif">${roundLabels[r]}</text>`;

        const nextSlots = [];

        currentSlots.forEach((match, mi) => {
            const my = 60 + mi * spacing + spacing / 2 - matchH / 2;

            const p1Text = match.p1 || '輪空';
            const p2Text = match.p2 || '輪空';
            const isBye1 = !match.p1;
            const isBye2 = !match.p2;
            const isByeMatch = isBye1 || isBye2;
            const matchNo = isByeMatch ? null : globalMatchNo++;

            // Box
            s += `<rect x="${rx}" y="${my}" width="${roundW}" height="${matchH}" rx="4" fill="white" stroke="#999" stroke-width="1"/>`;
            s += `<line x1="${rx}" y1="${my + slotH}" x2="${rx + roundW}" y2="${my + slotH}" stroke="#ddd"/>`;

            // Player names — doubles show 2 lines per slot
            const textY1 = my + Math.floor(slotH * 0.72);
            const textY2 = my + slotH + Math.floor(slotH * 0.72);
            if (isDoubles) {
                const lineH = Math.max(10, Math.floor(slotH * 0.45));
                const renderDoubles = (text, yBase, isBye) => {
                    if (isBye) {
                        s += `<text x="${rx + 8}" y="${yBase}" font-size="${fontSize}" font-family="Microsoft JhengHei, sans-serif" fill="#ccc">輪空</text>`;
                        return;
                    }
                    const parts = text.trim().split(/\s+/);
                    if (parts.length >= 3) {
                        s += `<text x="${rx + 8}" y="${yBase - Math.floor(lineH * 0.3)}" font-size="${fontSize}" font-family="Microsoft JhengHei, sans-serif" fill="#333">${escapeXml(parts[0])} ${escapeXml(parts[1])}</text>`;
                        s += `<text x="${rx + 8}" y="${yBase + Math.floor(lineH * 0.7)}" font-size="${fontSize}" font-family="Microsoft JhengHei, sans-serif" fill="#333">${escapeXml(parts[0])} ${escapeXml(parts.slice(2).join(' '))}</text>`;
                    } else {
                        s += `<text x="${rx + 8}" y="${yBase}" font-size="${fontSize}" font-family="Microsoft JhengHei, sans-serif" fill="#333">${escapeXml(text)}</text>`;
                    }
                };
                renderDoubles(p1Text, textY1, isBye1);
                renderDoubles(p2Text, textY2, isBye2);
            } else {
                s += `<text x="${rx + 8}" y="${textY1}" font-size="${fontSize}" font-family="Microsoft JhengHei, sans-serif" fill="${isBye1 ? '#ccc' : '#333'}">${escapeXml(p1Text)}</text>`;
                s += `<text x="${rx + 8}" y="${textY2}" font-size="${fontSize}" font-family="Microsoft JhengHei, sans-serif" fill="${isBye2 ? '#ccc' : '#333'}">${escapeXml(p2Text)}</text>`;
            }

            // Match number (skip for BYE matches)
            if (matchNo) s += matchNumLabel(rx + roundW + 14, my + matchH / 2, matchNo, fontSize);

            // Connector lines to next round
            if (r < rounds - 1) {
                const nextMi = Math.floor(mi / 2);
                const nextSpacing = baseH / (nMatches / 2);
                const nextY = 60 + nextMi * nextSpacing + nextSpacing / 2;
                const lineStartX = rx + roundW + 26;
                const nextRx = startX + (r + 1) * (roundW + gapRound);
                s += `<line x1="${lineStartX}" y1="${my + matchH / 2}" x2="${nextRx}" y2="${nextY}" stroke="#999" stroke-width="1"/>`;
            }

            // Determine winner for next round (only BYE auto-advance)
            let winner = null;
            if (isBye1 && !isBye2) winner = match.p2;
            else if (isBye2 && !isBye1) winner = match.p1;

            if (mi % 2 === 0) {
                nextSlots.push({ p1: winner, p2: null });
            } else {
                nextSlots[nextSlots.length - 1].p2 = winner;
            }
        });

        currentSlots = nextSlots;
    }

    // Winner labels
    const lastRx = startX + (rounds - 1) * (roundW + gapRound) + roundW + 30;
    s += `<text x="${lastRx + 20}" y="${60 + baseH / 2 - 10}" text-anchor="start" font-size="13" font-weight="bold" fill="#d4a017" font-family="Microsoft JhengHei, sans-serif">冠</text>`;
    s += `<text x="${lastRx + 20}" y="${60 + baseH / 2 + 10}" text-anchor="start" font-size="13" font-weight="bold" fill="#888" font-family="Microsoft JhengHei, sans-serif">亞</text>`;

    return { svg: s, height: totalH, width: svgW };
}

// ============================================================
// Utils
// ============================================================
function getAlignWidths(names) {
    let sw = 0, nw = 0;
    names.forEach(t => {
        const i = t.lastIndexOf(' ');
        if (i === -1) { nw = Math.max(nw, t.length); }
        else { sw = Math.max(sw, i); nw = Math.max(nw, t.length - i - 1); }
    });
    return { sw, nw };
}

function alignName(text, sw, nw) {
    const idx = text.lastIndexOf(' ');
    const jfy = 'display:inline-block;text-align:justify;text-align-last:justify;';
    if (idx === -1) {
        const safe = escapeXml(text);
        return text.length < nw
            ? '<span style="' + jfy + 'width:' + nw + 'em;">' + safe + '</span>' : safe;
    }
    const school = escapeXml(text.substring(0, idx));
    const name = escapeXml(text.substring(idx + 1));
    let sHtml = school.length < sw
        ? '<span style="' + jfy + 'width:' + sw + 'em;">' + school + '</span>' : school;
    let nHtml = name.length < nw
        ? '<span style="' + jfy + 'width:' + nw + 'em;">' + name + '</span>' : name;
    return sHtml + ' ' + nHtml;
}

function shuffle(arr) {
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
}

// ============================================================
// Download template Excel
// ============================================================
async function downloadTemplate() {
    try { await loadLib('xlsx'); } catch(err) { showToast(err.message, 'error'); return; }
    const wb = XLSX.utils.book_new();

    // Sheet 1: 3年級男單
    const s1 = XLSX.utils.aoa_to_sheet([
        ['學校', '姓名'],
        ['北一女中', '王小明'],
        ['建國中學', '李大華'],
        ['師大附中', '陳志偉'],
        ['中山女高', '林美玲'],
        ['成功高中', '張家豪'],
        ['景美女中', '黃雅琪'],
    ]);
    s1['!cols'] = [{ wch: 14 }, { wch: 12 }];
    XLSX.utils.book_append_sheet(wb, s1, '3男單');

    // Sheet 2: 3年級女單
    const s2 = XLSX.utils.aoa_to_sheet([
        ['學校', '姓名'],
        ['北一女中', '周小芬'],
        ['中山女高', '吳佳穎'],
        ['景美女中', '劉怡君'],
        ['松山高中', '趙雅婷'],
        ['大直高中', '鄭宜蓁'],
    ]);
    s2['!cols'] = [{ wch: 14 }, { wch: 12 }];
    XLSX.utils.book_append_sheet(wb, s2, '3女單');

    // Sheet 3: 3年級男雙
    const s3 = XLSX.utils.aoa_to_sheet([
        ['學校', '選手1', '選手2'],
        ['建國中學', '李大華', '陳志偉'],
        ['成功高中', '張家豪', '王俊傑'],
        ['師大附中', '林建宏', '許文彥'],
        ['松山高中', '楊志明', '蔡宗翰'],
    ]);
    s3['!cols'] = [{ wch: 14 }, { wch: 12 }, { wch: 12 }];
    XLSX.utils.book_append_sheet(wb, s3, '3男雙');

    // Sheet 4: 3年級混雙
    const s4 = XLSX.utils.aoa_to_sheet([
        ['學校', '選手1', '選手2'],
        ['北一女中', '王小明', '周小芬'],
        ['中山女高', '林美玲', '吳佳穎'],
        ['師大附中', '陳志偉', '劉怡君'],
    ]);
    s4['!cols'] = [{ wch: 14 }, { wch: 12 }, { wch: 12 }];
    XLSX.utils.book_append_sheet(wb, s4, '3混雙');

    XLSX.writeFile(wb, '羽球賽務匯入範本.xlsx');
    showToast('範本已下載', 'success');
}
</script>
</body>
</html>
